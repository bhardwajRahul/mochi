// generated by mochi-run, do not edit

# Mochi Source Files for LLM Ingestion

> Version: `0.1.11`

This document includes all core source files used by the Mochi interpreter and runtime toolchain.

## üìñ Overview

- **cmd/mochi/main.go**: Entry point of the Mochi CLI tool. Orchestrates example compilation, AST generation, and LLM-ready documentation output.
- **diagnostic/diagnostic.go**: Implements the structured error reporting engine with source context, suggestion hints, and error codes.
- **parser/parser.go**: Defines the Mochi parser using a top-down recursive descent approach. Transforms source code into an abstract syntax tree (AST).
- **ast/ast.go**: Contains data structures representing Mochi's typed abstract syntax tree (AST), including programs, expressions, and types.
- **ast/convert.go**: Converts parser output into typed AST used by later stages (e.g. interpreter, type checker).
- **ast/pretty.go**: Implements utilities to format and pretty-print AST nodes into human-readable forms (e.g. Lisp-style).
- **types/env.go**: Implements the static type environment (variable and function scopes used during type checking).
- **types/check.go**: Implements the Mochi type checker, verifying type correctness of variable declarations, expressions, and function bodies.
- **interpreter/interpreter.go**: Implements the Mochi interpreter which executes AST nodes in a given environment.

---

## cmd/mochi/main.go

```go
package main

import (
	"flag"
	"fmt"
	"os"

	"mochi/ast"
	"mochi/interpreter"
	"mochi/parser"
	"mochi/types"
)

var (
	version = "dev" // set via -ldflags

	showAST = flag.Bool("ast", false, "Print the parsed AST in Lisp format")
	run     = flag.Bool("run", false, "Interpret and execute the program")
)

func main() {
	flag.Usage = func() {
		fmt.Fprintf(flag.CommandLine.Output(), `Mochi Language (v%s)

Usage:
  mochi [options] <file.mochi>

Options:
`, version)
		flag.PrintDefaults()
	}

	flag.Parse()

	if flag.NArg() != 1 {
		flag.Usage()
		os.Exit(1)
	}

	filename := flag.Arg(0)

	//source, err := os.ReadFile(filename)
	//if err != nil {
	//	fmt.Fprintf(os.Stderr, "‚ùå Failed to read %s: %v\n", filename, err)
	//	os.Exit(1)
	//}

	prog, err := parser.Parse(filename)
	if err != nil {
		// ‚úÖ Use rich diagnostic output
		// fmt.Fprintln(os.Stderr, parser.FormatParseError(filename, err))
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}

	fmt.Printf("‚úÖ Parsed %s (Mochi v%s)\n", filename, version)

	// Always type check with fresh environment
	typeEnv := types.NewEnv(nil)
	errs := types.Check(prog, typeEnv)
	if len(errs) > 0 {
		fmt.Println("\n--- Type Errors ---")
		for _, e := range errs {
			fmt.Fprintf(os.Stderr, "‚ùå %v\n", e)
		}
		os.Exit(1)
	}

	if *showAST {
		fmt.Println("\n--- AST ---")
		tree := ast.FromProgram(prog)
		fmt.Println(tree.String())
	}

	if *run {
		fmt.Println("\n--- Running ---")
		interp := interpreter.New(prog, typeEnv)
		if err := interp.Run(); err != nil {
			fmt.Fprintf(os.Stderr, "‚ùå Runtime error: %v\n", err)
			os.Exit(1)
		}
	}
}

```

## diagnostic/diagnostic.go

```go
package diagnostic

import (
	"fmt"
	"os"
	"strings"

	"github.com/alecthomas/participle/v2/lexer"
)

// --------------------
// üîß Global Color Flag
// --------------------

// NoColor controls whether color output is disabled (can be set manually or from env)
var NoColor = os.Getenv("NO_COLOR") != ""

// --------------------
// üé® Color Functions
// --------------------

func Red(s string) string {
	if NoColor {
		return s
	}
	return "\033[31m" + s + "\033[0m"
}

func Yellow(s string) string {
	if NoColor {
		return s
	}
	return "\033[33m" + s + "\033[0m"
}

func Gray(s string) string {
	if NoColor {
		return s
	}
	return "\033[90m" + s + "\033[0m"
}

// --------------------
// üßæ Diagnostic Struct
// --------------------

// Diagnostic represents a structured, position-aware error with helpful context.
type Diagnostic struct {
	Code string         // Error code like "E1001"
	Pos  lexer.Position // File/line/col of error
	Msg  string         // Primary error message
	Help string         // Optional help message (guidance)
}

// Error implements error interface for Diagnostic.
func (d Diagnostic) Error() string {
	return d.Format()
}

// Format renders a multi-line Rust-style diagnostic.
func (d Diagnostic) Format() string {
	src, _ := os.ReadFile(d.Pos.Filename)
	lines := strings.Split(string(src), "\n")

	var line string
	if int(d.Pos.Line) <= len(lines) && d.Pos.Line > 0 {
		line = lines[d.Pos.Line-1]
	}

	marker := strings.Repeat(" ", int(d.Pos.Column)-1) + "^"

	out := []string{
		fmt.Sprintf("%s: %s", Red("error["+d.Code+"]"), d.Msg),
		fmt.Sprintf("  --> %s:%d:%d", d.Pos.Filename, d.Pos.Line, d.Pos.Column),
	}

	if line != "" {
		out = append(out, "",
			fmt.Sprintf("%s | %s", Gray(fmt.Sprintf("%3d", d.Pos.Line)), line),
			fmt.Sprintf("    | %s", Red(marker)),
		)
	}

	if d.Help != "" {
		out = append(out, "", Yellow("help:"), "  "+d.Help)
	}

	return strings.Join(out, "\n")
}

// --------------------
// ‚ú® Constructor Helpers
// --------------------

// New returns a new Diagnostic instance.
func New(code string, pos lexer.Position, msg, help string) Diagnostic {
	return Diagnostic{
		Code: code,
		Pos:  pos,
		Msg:  msg,
		Help: help,
	}
}

// Wrap creates an error interface from New (shorthand).
func Wrap(code string, pos lexer.Position, msg, help string) error {
	return New(code, pos, msg, help)
}

```

## parser/parser.go

```go
package parser

import (
	"github.com/alecthomas/participle/v2"
	"github.com/alecthomas/participle/v2/lexer"
)

// --- Mochi Lexer ---
var mochiLexer = lexer.MustSimple([]lexer.SimpleRule{
	{Name: "Comment", Pattern: `//[^\n]*`},
	{Name: "Bool", Pattern: `\b(true|false)\b`},
	{Name: "Ident", Pattern: `[a-zA-Z_][a-zA-Z0-9_]*`},
	{Name: "Float", Pattern: `\d+\.\d+`},
	{Name: "Int", Pattern: `\d+`},
	{Name: "String", Pattern: `"(?:\\.|[^"])*"`},
	{Name: "Punct", Pattern: `==|!=|<=|>=|=>|\.\.|[-+*/=<>!{}(),.:]`},
	{Name: "Whitespace", Pattern: `[ \t\n\r]+`},
})

// --- Program Structure ---

type Program struct {
	Pos        lexer.Position
	Statements []*Statement `@@*`
}

type Statement struct {
	Test   *TestBlock  `  @@`
	Expect *ExpectStmt `| @@`
	Agent  *AgentDecl  `| @@`
	Stream *StreamDecl `| @@`
	On     *OnHandler  `| @@`
	Let    *LetStmt    `| @@`
	Assign *AssignStmt `| @@`
	Fun    *FunStmt    `| @@`
	Return *ReturnStmt `| @@`
	If     *IfStmt     `| @@`
	For    *ForStmt    `| @@`
	Expr   *ExprStmt   `| @@`
}

// --- Test and Expect ---

type TestBlock struct {
	Pos  lexer.Position
	Test string       `"test"`
	Name string       `@String`
	Body []*Statement `"{" @@* "}"`
}

type ExpectStmt struct {
	Pos    lexer.Position
	Expect string `"expect"`
	Value  *Expr  `@@`
}

// --- If Statement ---

type IfStmt struct {
	Pos    lexer.Position
	If     string       `"if"`
	Cond   *Expr        `@@`
	Then   []*Statement `"{" @@* "}"`
	ElseIf *IfStmt      `[ "else" @@`
	Else   []*Statement `| "else" "{" @@* "}" ]`
}

// --- For Statement ---

type ForStmt struct {
	Pos   lexer.Position
	For   string       `"for"`
	Name  string       `@Ident`
	In    string       `"in"`
	Start *Expr        `@@`
	Dots  string       `".."`
	End   *Expr        `@@`
	Body  []*Statement `"{" @@* "}"`
}

// --- Type System ---

type TypeRef struct {
	Fun    *FunType `  @@`
	Simple *string  `| @Ident`
}

type FunType struct {
	Fun    string     `"fun"`
	Params []*TypeRef `"(" [ @@ { "," @@ } ] ")"`
	Return *TypeRef   `[ ":" @@ ]`
}

// --- Declarations & Statements ---

type LetStmt struct {
	Pos   lexer.Position
	Let   string   `"let"`
	Name  string   `@Ident`
	Type  *TypeRef `[ ":" @@ ]`
	Value *Expr    `[ "=" @@ ]`
}

type AssignStmt struct {
	Pos   lexer.Position
	Name  string `@Ident`
	Eq    string `"="`
	Value *Expr  `@@`
}

type FunStmt struct {
	Pos    lexer.Position
	Fun    string       `"fun"`
	Name   string       `@Ident`
	Params []*Param     `"(" [ @@ { "," @@ } ] ")"`
	Return *TypeRef     `[ ":" @@ ]`
	Body   []*Statement `"{" @@* "}"`
}

type ReturnStmt struct {
	Pos   lexer.Position
	Ret   string `"return"`
	Value *Expr  `@@`
}

type Param struct {
	Name string   `@Ident`
	Type *TypeRef `[ ":" @@ ]`
}

type ExprStmt struct {
	Pos  lexer.Position
	Expr *Expr `@@`
}

// --- Expressions ---

type Expr struct {
	Pos      lexer.Position
	Equality *Equality `@@`
}

type Equality struct {
	Left  *Comparison `@@`
	Right []*EqualOp  `@@*`
}

type EqualOp struct {
	Pos   lexer.Position
	Op    string      `@("==" | "!=")`
	Right *Comparison `@@`
}

type Comparison struct {
	Left  *Term     `@@`
	Right []*CompOp `@@*`
}

type CompOp struct {
	Pos   lexer.Position
	Op    string `@("<" | "<=" | ">" | ">=")`
	Right *Term  `@@`
}

type Term struct {
	Left  *Factor   `@@`
	Right []*TermOp `@@*`
}

type TermOp struct {
	Pos   lexer.Position
	Op    string  `@("+" | "-")`
	Right *Factor `@@`
}

type Factor struct {
	Left  *Unary      `@@`
	Right []*FactorOp `@@*`
}

type FactorOp struct {
	Pos   lexer.Position
	Op    string `@("*" | "/")`
	Right *Unary `@@`
}

type Unary struct {
	Pos   lexer.Position
	Ops   []string `{@("-" | "!")}`
	Value *Primary `@@`
}

type Primary struct {
	Pos      lexer.Position
	FunExpr  *FunExpr      `  @@`
	Call     *CallExpr     `| @@`
	Selector *SelectorExpr `| @@`
	Lit      *Literal      `| @@`
	Group    *Expr         `| "(" @@ ")"`
}

type FunExpr struct {
	Pos       lexer.Position
	Fun       string       `"fun"`
	Params    []*Param     `"(" [ @@ { "," @@ } ] ")"`
	Return    *TypeRef     `[ ":" @@ ]`
	Arrow     string       `"=>"`
	ExprBody  *Expr        `  @@`
	BlockBody []*Statement `| "{" @@* "}"`
}

// --- Atoms ---

type SelectorExpr struct {
	Root string   `@Ident`
	Tail []string `{ "." @Ident }`
}

type CallExpr struct {
	Pos    lexer.Position
	Func   string  `@Ident "("`
	Args   []*Expr `[ @@ { "," @@ } ]`
	RParen string  `")"`
}

type Literal struct {
	Pos   lexer.Position
	Float *string `  @Float`
	Int   *string `| @Int`
	Str   *string `| @String`
	Bool  *string `| @Bool`
}

// --- Stream / Struct Declarations ---

type StreamDecl struct {
	Pos    lexer.Position
	Stream string         `"stream"`
	Name   string         `@Ident`
	Fields []*StreamField `"{" @@* "}"`
}

type StreamField struct {
	Nested *StreamNestedField `  @@`
	Simple *StreamSimpleField `| @@`
}

type StreamSimpleField struct {
	Name string `@Ident`
	Type string `":" @Ident`
}

type StreamNestedField struct {
	Name string     `@Ident`
	Type string     `":"`
	Body *StructDef `@@`
}

type StructDef struct {
	LBrace string         `"{"`
	Fields []*StreamField `@@*`
	RBrace string         `"}"`
}

// --- On Handler ---

type OnHandler struct {
	Pos    lexer.Position
	On     string       `"on"`
	Stream string       `@Ident`
	As     string       `"as"`
	Alias  string       `@Ident`
	Body   []*Statement `"{" @@* "}"`
}

// --- Agent DSL ---

type AgentDecl struct {
	Pos   lexer.Position
	Agent string        `"agent"`
	Name  string        `@Ident`
	Body  []*AgentBlock `"{" @@* "}"`
}

type AgentBlock struct {
	Let    *LetStmt    `  @@`
	Assign *AssignStmt `| @@`
	On     *OnHandler  `| @@`
	Intent *IntentDecl `| @@`
}

type IntentDecl struct {
	Pos    lexer.Position
	Intent string       `"intent"`
	Name   string       `@Ident`
	Params []*Param     `"(" [ @@ { "," @@ } ] ")"`
	Return *TypeRef     `[ ":" @@ ]`
	Body   []*Statement `"{" @@* "}"`
}

// --- Parser ---

var Parser = participle.MustBuild[Program](
	participle.Lexer(mochiLexer),
	participle.Elide("Whitespace", "Comment"),
	participle.Unquote("String"),
	participle.UseLookahead(999),
)

```

## ast/ast.go

```go
package ast

import (
	"fmt"
	"regexp"
	"strings"
)

// Node is a simplified, uniform AST representation (inspired by Lisp)
type Node struct {
	Kind     string
	Value    any
	Children []*Node
}

// Print writes a compact Lisp-like tree to stdout
func (n *Node) Print(indent string) {
	fmt.Print(n.String())
}

// String returns the pretty-printed AST as a compact Lisp-like string
func (n *Node) String() string {
	var b strings.Builder
	write(&b, n, "")
	b.WriteString("\n")
	return b.String()
}

// write is a helper to recursively pretty-print the AST
func write(b *strings.Builder, n *Node, indent string) {
	b.WriteString(indent + "(" + n.Kind)
	if n.Value != nil {
		b.WriteString(" " + formatValue(n.Value))
	}

	if len(n.Children) == 0 {
		b.WriteString(")")
		return
	}

	// Check if all children are leaf nodes
	allLeaf := true
	for _, c := range n.Children {
		if len(c.Children) > 0 {
			allLeaf = false
			break
		}
	}

	if allLeaf {
		for _, c := range n.Children {
			b.WriteString(" (" + c.Kind)
			if c.Value != nil {
				b.WriteString(" " + formatValue(c.Value))
			}
			b.WriteString(")")
		}
		b.WriteString(")")
	} else {
		b.WriteString("\n")
		for _, c := range n.Children {
			write(b, c, indent+"  ")
			b.WriteString("\n")
		}
		b.WriteString(indent + ")")
	}
}

var safeIdent = regexp.MustCompile(`^[a-zA-Z0-9._-]+$`)

// formatValue returns a string representation of a value, quoting strings only when needed.
func formatValue(v any) string {
	switch s := v.(type) {
	case string:
		if safeIdent.MatchString(s) {
			return s
		}
		return fmt.Sprintf("%q", s)
	default:
		return fmt.Sprintf("%v", v)
	}
}

```

## ast/convert.go

```go
package ast

import "mochi/parser"

// FromProgram converts a parsed Program into an AST Node tree.
func FromProgram(p *parser.Program) *Node {
	root := &Node{Kind: "program"}
	for _, stmt := range p.Statements {
		root.Children = append(root.Children, FromStatement(stmt))
	}
	return root
}

// FromStatement converts a top-level Statement into a Node.
func FromStatement(s *parser.Statement) *Node {
	switch {
	case s.Let != nil:
		n := &Node{
			Kind:  "let",
			Value: s.Let.Name,
		}
		if s.Let.Type != nil {
			n.Children = append(n.Children, FromTypeRef(s.Let.Type))
		}
		if s.Let.Value != nil {
			n.Children = append(n.Children, FromExpr(s.Let.Value))
		}
		return n

	case s.Assign != nil:
		return &Node{
			Kind:  "assign",
			Value: s.Assign.Name,
			Children: []*Node{
				FromExpr(s.Assign.Value),
			},
		}

	case s.Fun != nil:
		n := &Node{Kind: "fun", Value: s.Fun.Name}
		for _, param := range s.Fun.Params {
			paramNode := &Node{Kind: "param", Value: param.Name}
			if param.Type != nil {
				paramNode.Children = append(paramNode.Children, FromTypeRef(param.Type))
			}
			n.Children = append(n.Children, paramNode)
		}
		if s.Fun.Return != nil {
			n.Children = append(n.Children, FromTypeRef(s.Fun.Return))
		}
		for _, stmt := range s.Fun.Body {
			n.Children = append(n.Children, FromStatement(stmt))
		}
		return n

	case s.Return != nil:
		return &Node{Kind: "return", Children: []*Node{FromExpr(s.Return.Value)}}

	case s.Expr != nil:
		return &Node{Kind: "exprstmt", Children: []*Node{FromExpr(s.Expr.Expr)}}

	case s.If != nil:
		return fromIfStmt(s.If)

	case s.For != nil:
		return fromForStmt(s.For)

	case s.Agent != nil:
		n := &Node{Kind: "agent", Value: s.Agent.Name}
		for _, block := range s.Agent.Body {
			switch {
			case block.Let != nil:
				n.Children = append(n.Children, FromStatement(&parser.Statement{Let: block.Let}))
			case block.Assign != nil:
				n.Children = append(n.Children, FromStatement(&parser.Statement{Assign: block.Assign}))
			case block.On != nil:
				n.Children = append(n.Children, fromOnHandler(block.On))
			case block.Intent != nil:
				n.Children = append(n.Children, fromIntent(block.Intent))
			}
		}
		return n

	case s.On != nil:
		return fromOnHandler(s.On)

	case s.Stream != nil:
		n := &Node{Kind: "stream", Value: s.Stream.Name}
		for _, field := range s.Stream.Fields {
			n.Children = append(n.Children, fromStreamField(field))
		}
		return n

	case s.Test != nil:
		n := &Node{Kind: "test", Value: s.Test.Name}
		for _, stmt := range s.Test.Body {
			n.Children = append(n.Children, FromStatement(stmt))
		}
		return n

	case s.Expect != nil:
		return &Node{Kind: "expect", Children: []*Node{FromExpr(s.Expect.Value)}}

	default:
		return &Node{Kind: "unknown"}
	}
}

func fromIfStmt(stmt *parser.IfStmt) *Node {
	n := &Node{Kind: "if"}
	n.Children = append(n.Children, FromExpr(stmt.Cond))
	thenBlock := &Node{Kind: "block"}
	for _, stmt := range stmt.Then {
		thenBlock.Children = append(thenBlock.Children, FromStatement(stmt))
	}
	n.Children = append(n.Children, thenBlock)

	if stmt.ElseIf != nil {
		n.Children = append(n.Children, fromIfStmt(stmt.ElseIf))
	} else if stmt.Else != nil {
		elseBlock := &Node{Kind: "block"}
		for _, stmt := range stmt.Else {
			elseBlock.Children = append(elseBlock.Children, FromStatement(stmt))
		}
		n.Children = append(n.Children, elseBlock)
	}

	return n
}

func fromForStmt(f *parser.ForStmt) *Node {
	return &Node{
		Kind:  "for",
		Value: f.Name,
		Children: []*Node{
			{Kind: "range", Children: []*Node{
				FromExpr(f.Start),
				FromExpr(f.End),
			}},
			{Kind: "block", Children: mapStatements(f.Body)},
		},
	}
}

func mapStatements(stmts []*parser.Statement) []*Node {
	var out []*Node
	for _, s := range stmts {
		out = append(out, FromStatement(s))
	}
	return out
}

func fromOnHandler(h *parser.OnHandler) *Node {
	n := &Node{Kind: "on", Value: h.Stream}
	for _, stmt := range h.Body {
		n.Children = append(n.Children, FromStatement(stmt))
	}
	return n
}

func fromIntent(i *parser.IntentDecl) *Node {
	n := &Node{Kind: "intent", Value: i.Name}
	for _, param := range i.Params {
		paramNode := &Node{Kind: "param", Value: param.Name}
		if param.Type != nil {
			paramNode.Children = append(paramNode.Children, FromTypeRef(param.Type))
		}
		n.Children = append(n.Children, paramNode)
	}
	if i.Return != nil {
		n.Children = append(n.Children, FromTypeRef(i.Return))
	}
	for _, stmt := range i.Body {
		n.Children = append(n.Children, FromStatement(stmt))
	}
	return n
}

func fromStreamField(f *parser.StreamField) *Node {
	if f.Simple != nil {
		return &Node{
			Kind:  "field",
			Value: f.Simple.Name + ":" + f.Simple.Type,
		}
	}
	if f.Nested != nil {
		n := &Node{
			Kind:  "field",
			Value: f.Nested.Name + ":" + f.Nested.Type,
		}
		for _, sf := range f.Nested.Body.Fields {
			n.Children = append(n.Children, fromStreamField(sf))
		}
		return n
	}
	return &Node{Kind: "field"}
}

// FromExpr converts a high-level expression.
func FromExpr(e *parser.Expr) *Node {
	return FromEquality(e.Equality)
}

func FromEquality(e *parser.Equality) *Node {
	n := FromComparison(e.Left)
	for _, op := range e.Right {
		n = &Node{Kind: "binary", Value: op.Op, Children: []*Node{n, FromComparison(op.Right)}}
	}
	return n
}

func FromComparison(c *parser.Comparison) *Node {
	n := FromTerm(c.Left)
	for _, op := range c.Right {
		n = &Node{Kind: "binary", Value: op.Op, Children: []*Node{n, FromTerm(op.Right)}}
	}
	return n
}

func FromTerm(t *parser.Term) *Node {
	n := FromFactor(t.Left)
	for _, op := range t.Right {
		n = &Node{Kind: "binary", Value: op.Op, Children: []*Node{n, FromFactor(op.Right)}}
	}
	return n
}

func FromFactor(f *parser.Factor) *Node {
	n := FromUnary(f.Left)
	for _, op := range f.Right {
		n = &Node{Kind: "binary", Value: op.Op, Children: []*Node{n, FromUnary(op.Right)}}
	}
	return n
}

func FromUnary(u *parser.Unary) *Node {
	n := FromPrimary(u.Value)
	for i := len(u.Ops) - 1; i >= 0; i-- {
		n = &Node{Kind: "unary", Value: u.Ops[i], Children: []*Node{n}}
	}
	return n
}

func FromPrimary(p *parser.Primary) *Node {
	switch {
	case p.FunExpr != nil:
		n := &Node{Kind: "funexpr"}
		for _, param := range p.FunExpr.Params {
			paramNode := &Node{Kind: "param", Value: param.Name}
			if param.Type != nil {
				paramNode.Children = append(paramNode.Children, FromTypeRef(param.Type))
			}
			n.Children = append(n.Children, paramNode)
		}
		if p.FunExpr.Return != nil {
			n.Children = append(n.Children, FromTypeRef(p.FunExpr.Return))
		}
		if p.FunExpr.ExprBody != nil {
			n.Children = append(n.Children, FromExpr(p.FunExpr.ExprBody))
		} else if len(p.FunExpr.BlockBody) > 0 {
			block := &Node{Kind: "block"}
			for _, stmt := range p.FunExpr.BlockBody {
				block.Children = append(block.Children, FromStatement(stmt))
			}
			n.Children = append(n.Children, block)
		}
		return n

	case p.Call != nil:
		n := &Node{Kind: "call", Value: p.Call.Func}
		for _, arg := range p.Call.Args {
			n.Children = append(n.Children, FromExpr(arg))
		}
		return n

	case p.Selector != nil:
		n := &Node{Kind: "selector", Value: p.Selector.Root}
		for _, field := range p.Selector.Tail {
			n = &Node{Kind: "selector", Value: field, Children: []*Node{n}}
		}
		return n

	case p.Lit != nil:
		switch {
		case p.Lit.Float != nil:
			return &Node{Kind: "float", Value: *p.Lit.Float}
		case p.Lit.Int != nil:
			return &Node{Kind: "int", Value: *p.Lit.Int}
		case p.Lit.Str != nil:
			return &Node{Kind: "string", Value: *p.Lit.Str}
		case p.Lit.Bool != nil:
			return &Node{Kind: "bool", Value: *p.Lit.Bool}
		}

	case p.Group != nil:
		return &Node{Kind: "group", Children: []*Node{FromExpr(p.Group)}}
	}
	return &Node{Kind: "unknown"}
}

// FromTypeRef converts a TypeRef (including function types) to a Node.
func FromTypeRef(t *parser.TypeRef) *Node {
	if t == nil {
		return nil
	}
	if t.Fun != nil {
		n := &Node{Kind: "typefun"}
		for _, param := range t.Fun.Params {
			n.Children = append(n.Children, FromTypeRef(param))
		}
		if t.Fun.Return != nil {
			n.Children = append(n.Children, FromTypeRef(t.Fun.Return))
		}
		return n
	}
	return &Node{Kind: "type", Value: *t.Simple}
}

```

## ast/pretty.go

```go
package ast

import (
	"fmt"

	"mochi/parser"
)

// PrettyStatement returns a readable description of a statement, including its source position.
func PrettyStatement(s *parser.Statement) string {
	switch {
	case s.Let != nil:
		return fmt.Sprintf("%s: let %s", s.Let.Pos, s.Let.Name)

	case s.Assign != nil:
		return fmt.Sprintf("%s: %s = ...", s.Assign.Pos, s.Assign.Name)

	case s.Fun != nil:
		return fmt.Sprintf("%s: fun %s(%d params)", s.Fun.Pos, s.Fun.Name, len(s.Fun.Params))

	case s.Expr != nil:
		return fmt.Sprintf("%s: expression", s.Expr.Pos)

	case s.Return != nil:
		return fmt.Sprintf("%s: return ...", s.Return.Pos)

	case s.If != nil:
		return fmt.Sprintf("%s: if ...", s.If.Pos)

	case s.For != nil:
		return fmt.Sprintf("%s: for %s in ...", s.For.Pos, s.For.Name)

	case s.On != nil:
		return fmt.Sprintf("%s: on %s as %s", s.On.Pos, s.On.Stream, s.On.Alias)

	case s.Agent != nil:
		return fmt.Sprintf("%s: agent %s", s.Agent.Pos, s.Agent.Name)

	case s.Stream != nil:
		return fmt.Sprintf("%s: stream %s", s.Stream.Pos, s.Stream.Name)

	case s.Test != nil:
		return fmt.Sprintf("%s: test %s", s.Test.Pos, s.Test.Name)

	case s.Expect != nil:
		return fmt.Sprintf("%s: expect %v", s.Expect.Pos, s.Expect.Value)

	default:
		return "unknown statement"
	}
}

```

## types/env.go

```go
package types

import (
	"fmt"
	"io"
	"mochi/parser"
	"os"
)

// Env holds both type and value bindings for variables and functions.
type Env struct {
	parent *Env

	types  map[string]Type            // static types
	values map[string]any             // runtime values
	funcs  map[string]*parser.FunStmt // function declarations

	output io.Writer // default: os.Stdout
}

// NewEnv creates a new lexical scope environment.
func NewEnv(parent *Env) *Env {
	return &Env{
		parent: parent,
		types:  make(map[string]Type),
		values: make(map[string]any),
		funcs:  make(map[string]*parser.FunStmt),
		output: os.Stdout,
	}
}

// --- Type (Static) Binding ---

// SetVar defines a variable's static type.
func (e *Env) SetVar(name string, typ Type) {
	e.types[name] = typ
}

// GetVar looks up a variable's static type.
func (e *Env) GetVar(name string) (Type, error) {
	if t, ok := e.types[name]; ok {
		return t, nil
	}
	if e.parent != nil {
		return e.parent.GetVar(name)
	}
	return nil, fmt.Errorf("undefined variable: %s", name)
}

// --- Value (Runtime) Binding ---

// SetValue sets a variable's runtime value.
func (e *Env) SetValue(name string, val any) {
	e.values[name] = val
}

// UpdateValue modifies an existing variable's runtime value.
func (e *Env) UpdateValue(name string, val any) error {
	if _, ok := e.values[name]; ok {
		e.values[name] = val
		return nil
	}
	if e.parent != nil {
		return e.parent.UpdateValue(name, val)
	}
	return fmt.Errorf("variable not declared: %s", name)
}

// GetValue retrieves a runtime value.
func (e *Env) GetValue(name string) (any, error) {
	if val, ok := e.values[name]; ok {
		return val, nil
	}
	if e.parent != nil {
		return e.parent.GetValue(name)
	}
	return nil, fmt.Errorf("undefined variable: %s", name)
}

// --- Function Binding ---

// SetFunc binds a named function.
func (e *Env) SetFunc(name string, fn *parser.FunStmt) {
	e.funcs[name] = fn
}

// SetFuncType binds a function name to its static type.
func (e *Env) SetFuncType(name string, typ Type) {
	e.types[name] = typ
}

// GetFunc retrieves a function definition.
func (e *Env) GetFunc(name string) (*parser.FunStmt, bool) {
	if fn, ok := e.funcs[name]; ok {
		return fn, true
	}
	if e.parent != nil {
		return e.parent.GetFunc(name)
	}
	return nil, false
}

// Copy creates a shallow copy of the current environment with no parent.
// Useful for closures capturing current bindings.
func (e *Env) Copy() *Env {
	newEnv := &Env{
		parent: nil, // flatten parent chain
		types:  make(map[string]Type, len(e.types)),
		values: make(map[string]any, len(e.values)),
		funcs:  make(map[string]*parser.FunStmt, len(e.funcs)),
		output: e.output,
	}
	for k, v := range e.types {
		newEnv.types[k] = v
	}
	for k, v := range e.values {
		newEnv.values[k] = v
	}
	for k, v := range e.funcs {
		newEnv.funcs[k] = v
	}
	return newEnv
}

// --- Output Control ---

// SetWriter sets the output destination.
func (e *Env) SetWriter(w io.Writer) {
	e.output = w
}

// Writer returns the current output writer.
func (e *Env) Writer() io.Writer {
	return e.output
}

```

## types/check.go

```go
package types

import (
	"fmt"
	"github.com/alecthomas/participle/v2/lexer"
	"mochi/parser"
)

// --- Type System ---

type Type interface {
	String() string
	Equal(Type) bool
}

type IntType struct{}

func (IntType) String() string    { return "int" }
func (IntType) Equal(t Type) bool { _, ok := t.(IntType); return ok }

type FloatType struct{}

func (FloatType) String() string    { return "float" }
func (FloatType) Equal(t Type) bool { _, ok := t.(FloatType); return ok }

type StringType struct{}

func (StringType) String() string    { return "string" }
func (StringType) Equal(t Type) bool { _, ok := t.(StringType); return ok }

type BoolType struct{}

func (BoolType) String() string    { return "bool" }
func (BoolType) Equal(t Type) bool { _, ok := t.(BoolType); return ok }

type VoidType struct{}

func (VoidType) String() string    { return "void" }
func (VoidType) Equal(t Type) bool { _, ok := t.(VoidType); return ok }

type AnyType struct{}

func (AnyType) String() string    { return "any" }
func (AnyType) Equal(t Type) bool { return true }

type TypeVar struct {
	Name string
}

func (t *TypeVar) String() string { return t.Name }
func (t *TypeVar) Equal(other Type) bool {
	if o, ok := other.(*TypeVar); ok {
		return t.Name == o.Name
	}
	return false
}

type FuncType struct {
	Params []Type
	Return Type
}

func (f FuncType) String() string {
	s := "fun("
	for i, p := range f.Params {
		if i > 0 {
			s += ", "
		}
		s += p.String()
	}
	s += ")"
	if f.Return != nil && f.Return.String() != "void" {
		s += ": " + f.Return.String()
	}
	return s
}

func (f FuncType) Equal(t Type) bool {
	other, ok := t.(FuncType)
	if !ok || len(f.Params) != len(other.Params) {
		return false
	}
	for i := range f.Params {
		if !f.Params[i].Equal(other.Params[i]) {
			return false
		}
	}
	return f.Return.Equal(other.Return)
}

type BuiltinFuncType struct{}

func (BuiltinFuncType) String() string    { return "fun(...): void" }
func (BuiltinFuncType) Equal(t Type) bool { _, ok := t.(BuiltinFuncType); return ok }

// --- Checker Entry Point ---

func Check(prog *parser.Program, env *Env) []error {
	env.SetVar("print", BuiltinFuncType{})
	var errs []error
	for _, stmt := range prog.Statements {
		if err := checkStmt(stmt, env); err != nil {
			errs = append(errs, err)
		}
	}
	return errs
}

// --- Helpers ---

func resolveTypeRef(t *parser.TypeRef) Type {
	if t.Fun != nil {
		params := []Type{}
		for _, p := range t.Fun.Params {
			params = append(params, resolveTypeRef(p))
		}
		var ret Type = VoidType{}
		if t.Fun.Return != nil {
			ret = resolveTypeRef(t.Fun.Return)
		}
		return FuncType{Params: params, Return: ret}
	}
	switch *t.Simple {
	case "int":
		return IntType{}
	case "float":
		return FloatType{}
	case "string":
		return StringType{}
	case "bool":
		return BoolType{}
	default:
		return AnyType{}
	}
}

func checkStmt(s *parser.Statement, env *Env) error {
	switch {
	case s.Let != nil:
		name := s.Let.Name
		var typ Type
		if s.Let.Type != nil {
			typ = resolveTypeRef(s.Let.Type)
			if s.Let.Value != nil {
				exprType, err := checkExprWithExpected(s.Let.Value, env, typ)
				if err != nil {
					return err
				}
				if !typ.Equal(exprType) {
					return errTypeMismatch(s.Let.Pos, typ, exprType)
				}
			}
		} else if s.Let.Value != nil {
			var err error
			typ, err = checkExprWithExpected(s.Let.Value, env, nil)
			if err != nil {
				return err
			}
		} else {
			return errLetMissingTypeOrValue(s.Let.Pos)
		}
		env.SetVar(name, typ)
		return nil

	case s.Assign != nil:
		rhsType, err := checkExprWithExpected(s.Assign.Value, env, nil)
		if err != nil {
			return err
		}
		lhsType, err := env.GetVar(s.Assign.Name)
		if err != nil {
			return errAssignUndeclared(s.Assign.Pos, s.Assign.Name)
		}
		if !lhsType.Equal(rhsType) {
			return errCannotAssign(s.Assign.Pos, rhsType, s.Assign.Name, lhsType)
		}
		return nil

	case s.Fun != nil:
		name := s.Fun.Name
		params := []Type{}
		for _, p := range s.Fun.Params {
			if p.Type == nil {
				return errParamMissingType(s.Fun.Pos, p.Name)
			}
			params = append(params, resolveTypeRef(p.Type))
		}
		var ret Type = VoidType{}
		if s.Fun.Return != nil {
			ret = resolveTypeRef(s.Fun.Return)
		}
		env.SetVar(name, FuncType{Params: params, Return: ret})

		child := NewEnv(env)
		for i, p := range s.Fun.Params {
			child.SetVar(p.Name, params[i])
		}
		for _, stmt := range s.Fun.Body {
			if err := checkStmt(stmt, child); err != nil {
				return err
			}
		}
		return nil

	case s.Expr != nil:
		_, err := checkExprWithExpected(s.Expr.Expr, env, nil)
		return err

	case s.Return != nil:
		_, err := checkExprWithExpected(s.Return.Value, env, nil)
		return err

	case s.Test != nil:
		child := NewEnv(env)
		for _, inner := range s.Test.Body {
			if err := checkStmt(inner, child); err != nil {
				return err
			}
		}
		return nil

	case s.Expect != nil:
		t, err := checkExprWithExpected(s.Expect.Value, env, BoolType{})
		if err != nil {
			return err
		}
		if !t.Equal(BoolType{}) {
			return errExpectBoolean(s.Expect.Pos)
		}
		return nil
	}
	return nil
}

func checkExpr(e *parser.Expr, env *Env) (Type, error) {
	return checkExprWithExpected(e, env, nil)
}

func checkExprWithExpected(e *parser.Expr, env *Env, expected Type) (Type, error) {
	return checkEquality(e.Equality, env, expected)
}

func checkEquality(e *parser.Equality, env *Env, expected Type) (Type, error) {
	left, err := checkComparison(e.Left, env, nil)
	if err != nil {
		return nil, err
	}
	for _, op := range e.Right {
		right, err := checkComparison(op.Right, env, nil)
		if err != nil {
			return nil, err
		}
		if !left.Equal(right) {
			return nil, errIncompatibleEquality(op.Pos)
		}
		left = BoolType{}
	}
	return left, nil
}

func checkComparison(c *parser.Comparison, env *Env, expected Type) (Type, error) {
	left, err := checkTerm(c.Left, env, nil)
	if err != nil {
		return nil, err
	}
	for _, op := range c.Right {
		right, err := checkTerm(op.Right, env, nil)
		if err != nil {
			return nil, err
		}
		if !left.Equal(right) {
			return nil, errIncompatibleComparison(op.Pos)
		}
		left = BoolType{}
	}
	return left, nil
}

func checkTerm(t *parser.Term, env *Env, expected Type) (Type, error) {
	left, err := checkFactor(t.Left, env, nil)
	if err != nil {
		return nil, err
	}
	for _, op := range t.Right {
		right, err := checkFactor(op.Right, env, nil)
		if err != nil {
			return nil, err
		}
		if !left.Equal(right) {
			return nil, errTypeMismatch(op.Pos, left, right)
		}
	}
	return left, nil
}

func checkFactor(f *parser.Factor, env *Env, expected Type) (Type, error) {
	left, err := checkUnary(f.Left, env, nil)
	if err != nil {
		return nil, err
	}
	for _, op := range f.Right {
		right, err := checkUnary(op.Right, env, nil)
		if err != nil {
			return nil, err
		}
		if !left.Equal(right) {
			return nil, errTypeMismatch(op.Pos, left, right)
		}
	}
	return left, nil
}

func checkUnary(u *parser.Unary, env *Env, expected Type) (Type, error) {
	return checkPrimary(u.Value, env, expected)
}

func checkPrimary(p *parser.Primary, env *Env, expected Type) (Type, error) {
	switch {
	case p.Lit != nil:
		switch {
		case p.Lit.Int != nil:
			return IntType{}, nil
		case p.Lit.Float != nil:
			return FloatType{}, nil
		case p.Lit.Str != nil:
			return StringType{}, nil
		case p.Lit.Bool != nil:
			return BoolType{}, nil
		}

	case p.Selector != nil:
		typ, err := env.GetVar(p.Selector.Root)
		if err != nil {
			return nil, errUnknownVariable(p.Pos, p.Selector.Root)
		}
		// TODO: implement proper struct/stream field access checking
		return typ, nil

	case p.Call != nil:
		fnType, err := env.GetVar(p.Call.Func)
		if err != nil {
			return nil, errUnknownFunction(p.Pos, p.Call.Func)
		}

		switch ft := fnType.(type) {
		case FuncType:
			argCount := len(p.Call.Args)
			paramCount := len(ft.Params)

			if argCount > paramCount {
				return nil, errTooManyArgs(p.Pos, paramCount, argCount)
			}

			for i := 0; i < argCount; i++ {
				argType, err := checkExprWithExpected(p.Call.Args[i], env, ft.Params[i])
				if err != nil {
					return nil, err
				}
				if !argType.Equal(ft.Params[i]) {
					return nil, errArgTypeMismatch(p.Pos, i, ft.Params[i], argType)
				}
			}

			if argCount == paramCount {
				return ft.Return, nil
			}
			return curryFuncType(ft.Params[argCount:], ft.Return), nil

		case BuiltinFuncType:
			for _, arg := range p.Call.Args {
				if _, err := checkExpr(arg, env); err != nil {
					return nil, err
				}
			}
			return VoidType{}, nil

		default:
			return nil, errNotFunction(p.Pos, p.Call.Func)
		}

	case p.FunExpr != nil:
		return checkFunExpr(p.FunExpr, env, expected, p.Pos)

	case p.Group != nil:
		return checkExprWithExpected(p.Group, env, expected)
	}

	return nil, errInvalidPrimary(p.Pos)
}

func checkFunExpr(f *parser.FunExpr, env *Env, expected Type, pos lexer.Position) (Type, error) {
	var expectedFunc *FuncType
	if ft, ok := expected.(FuncType); ok {
		expectedFunc = &ft
	}

	paramTypes := make([]Type, len(f.Params))
	for i, p := range f.Params {
		if p.Type != nil {
			paramTypes[i] = resolveTypeRef(p.Type)
		} else if expectedFunc != nil && i < len(expectedFunc.Params) {
			paramTypes[i] = expectedFunc.Params[i]
		} else {
			paramTypes[i] = &TypeVar{Name: fmt.Sprintf("T_%s", p.Name)}
		}
	}

	var declaredRet Type = VoidType{}
	if f.Return != nil {
		declaredRet = resolveTypeRef(f.Return)
	} else if expectedFunc != nil {
		declaredRet = expectedFunc.Return
	} else {
		declaredRet = &TypeVar{Name: "R"}
	}

	child := NewEnv(env)
	for i, p := range f.Params {
		child.SetVar(p.Name, paramTypes[i])
	}

	if f.ExprBody != nil {
		actualRet, err := checkExprWithExpected(f.ExprBody, child, declaredRet)
		if err != nil {
			return nil, err
		}
		declaredRet = actualRet
	} else {
		for _, stmt := range f.BlockBody {
			if err := checkStmt(stmt, child); err != nil {
				return nil, err
			}
		}
	}

	return FuncType{Params: paramTypes, Return: declaredRet}, nil
}

func curryFuncType(params []Type, ret Type) Type {
	if len(params) == 0 {
		return ret
	}
	return FuncType{
		Params: []Type{params[0]},
		Return: curryFuncType(params[1:], ret),
	}
}

```

## interpreter/interpreter.go

```go
package interpreter

import (
	"errors"
	"fmt"
	"github.com/alecthomas/participle/v2/lexer"
	"mochi/ast"
	"mochi/parser"
	"mochi/types"
	"strings"
)

// Interpreter executes Mochi programs using a shared runtime and type environment.
type Interpreter struct {
	prog  *parser.Program
	env   *types.Env
	types *types.Env
}

func New(prog *parser.Program, typesEnv *types.Env) *Interpreter {
	return &Interpreter{
		prog:  prog,
		env:   types.NewEnv(nil),
		types: typesEnv,
	}
}

func (i *Interpreter) Env() *types.Env { return i.env }

func (i *Interpreter) Run() error {
	var testFailures []error

	for _, stmt := range i.prog.Statements {
		if stmt.Test != nil {
			name := stmt.Test.Name
			fmt.Printf("üîç Test %s\n", name)

			child := types.NewEnv(i.env)
			interp := &Interpreter{prog: i.prog, env: child, types: i.types}

			var failed error
			for _, s := range stmt.Test.Body {
				if err := interp.evalStmt(s); err != nil {
					failed = fmt.Errorf("‚ùå %s: %w", name, err)
					break // stop this test, but continue others
				}
			}

			if failed != nil {
				fmt.Println(failed)
				testFailures = append(testFailures, failed)
			} else {
				fmt.Printf("‚úÖ %s passed\n", name)
			}

		} else {
			if err := i.evalStmt(stmt); err != nil {
				return err // still stop on non-test failure
			}
		}
	}

	if len(testFailures) > 0 {
		var sb strings.Builder
		fmt.Fprintf(&sb, "\nüí• %d test(s) failed:\n", len(testFailures))
		for _, err := range testFailures {
			fmt.Fprintf(&sb, "  - %v\n", err)
		}
		return errors.New(sb.String())
	}

	return nil
}

type closure struct {
	Fn         *parser.FunExpr
	Env        *types.Env
	Args       []any
	FullParams []*parser.Param
}

func (c closure) String() string {
	return fmt.Sprintf("<closure %d/%d args>", len(c.Args), len(c.Fn.Params)+len(c.Args))
}

// --- Statement Evaluation ---

func (i *Interpreter) evalStmt(s *parser.Statement) error {
	switch {
	case s.Let != nil:
		val := any(nil)
		var err error
		if s.Let.Value != nil {
			val, err = i.evalExpr(s.Let.Value)
			if err != nil {
				return err
			}
		}
		i.env.SetValue(s.Let.Name, val)
		return nil

	case s.Assign != nil:
		val, err := i.evalExpr(s.Assign.Value)
		if err != nil {
			return err
		}
		return i.env.UpdateValue(s.Assign.Name, val)

	case s.Expr != nil:
		_, err := i.evalExpr(s.Expr.Expr)
		return err

	case s.Fun != nil:
		i.env.SetFunc(s.Fun.Name, s.Fun)
		return nil

	case s.Return != nil:
		val, err := i.evalExpr(s.Return.Value)
		if err != nil {
			return err
		}
		return returnSignal{val}

	case s.If != nil:
		return i.evalIf(s.If)

	case s.For != nil:
		return i.evalFor(s.For)

	case s.Test != nil:
		fmt.Printf("üîç Test %s\n", s.Test.Name)
		child := types.NewEnv(i.env)
		interp := &Interpreter{prog: i.prog, env: child, types: i.types}
		for _, stmt := range s.Test.Body {
			if err := interp.evalStmt(stmt); err != nil {
				return fmt.Errorf("‚ùå %s: %w", s.Test.Name, err)
			}
		}
		fmt.Printf("‚úÖ %s passed\n", s.Test.Name)
		return nil

	case s.Expect != nil:
		val, err := i.evalExpr(s.Expect.Value)
		if err != nil {
			return err
		}
		if b, ok := val.(bool); !ok || !b {
			return fmt.Errorf("expect failed: %s", ast.PrettyStatement(s))
		}
		return nil

	default:
		return fmt.Errorf("unsupported statement: %s", ast.PrettyStatement(s))
	}
}

func (i *Interpreter) evalIf(stmt *parser.IfStmt) error {
	condVal, err := i.evalExpr(stmt.Cond)
	if err != nil {
		return err
	}
	if truthy(condVal) {
		for _, s := range stmt.Then {
			if err := i.evalStmt(s); err != nil {
				return err
			}
		}
		return nil
	}
	if stmt.ElseIf != nil {
		return i.evalIf(stmt.ElseIf)
	}
	for _, s := range stmt.Else {
		if err := i.evalStmt(s); err != nil {
			return err
		}
	}
	return nil
}

func (i *Interpreter) evalFor(stmt *parser.ForStmt) error {
	fromVal, err := i.evalExpr(stmt.Start)
	if err != nil {
		return err
	}
	toVal, err := i.evalExpr(stmt.End)
	if err != nil {
		return err
	}
	fromInt, ok1 := fromVal.(int)
	toInt, ok2 := toVal.(int)
	if !ok1 || !ok2 {
		return errInvalidRangeBounds(stmt.Pos, fmt.Sprintf("%T", fromVal), fmt.Sprintf("%T", toVal))
	}
	for x := fromInt; x < toInt; x++ {
		i.env.SetValue(stmt.Name, x)
		for _, s := range stmt.Body {
			if err := i.evalStmt(s); err != nil {
				return err
			}
		}
	}
	return nil
}

// --- Expression Evaluation ---

func (i *Interpreter) evalExpr(e *parser.Expr) (any, error) {
	if e == nil {
		return nil, errors.New("nil expression")
	}
	return i.evalEquality(e.Equality)
}

func (i *Interpreter) evalEquality(e *parser.Equality) (any, error) {
	left, err := i.evalComparison(e.Left)
	if err != nil {
		return nil, err
	}
	for _, op := range e.Right {
		right, err := i.evalComparison(op.Right)
		if err != nil {
			return nil, err
		}
		left, err = applyBinary(op.Pos, left, op.Op, right)
		if err != nil {
			return nil, err
		}
	}
	return left, nil
}

func (i *Interpreter) evalComparison(c *parser.Comparison) (any, error) {
	left, err := i.evalTerm(c.Left)
	if err != nil {
		return nil, err
	}
	for _, op := range c.Right {
		right, err := i.evalTerm(op.Right)
		if err != nil {
			return nil, err
		}
		left, err = applyBinary(op.Pos, left, op.Op, right)
		if err != nil {
			return nil, err
		}
	}
	return left, nil
}

func (i *Interpreter) evalTerm(t *parser.Term) (any, error) {
	left, err := i.evalFactor(t.Left)
	if err != nil {
		return nil, err
	}
	for _, op := range t.Right {
		right, err := i.evalFactor(op.Right)
		if err != nil {
			return nil, err
		}
		left, err = applyBinary(op.Pos, left, op.Op, right)
		if err != nil {
			return nil, err
		}
	}
	return left, nil
}

func (i *Interpreter) evalFactor(f *parser.Factor) (any, error) {
	left, err := i.evalUnary(f.Left)
	if err != nil {
		return nil, err
	}
	for _, op := range f.Right {
		right, err := i.evalUnary(op.Right)
		if err != nil {
			return nil, err
		}
		left, err = applyBinary(op.Pos, left, op.Op, right)
		if err != nil {
			return nil, err
		}
	}
	return left, nil
}

func (i *Interpreter) evalUnary(u *parser.Unary) (any, error) {
	val, err := i.evalPrimary(u.Value)
	if err != nil {
		return nil, err
	}
	for j := len(u.Ops) - 1; j >= 0; j-- {
		val, err = applyUnary(u.Pos, u.Ops[j], val)
		if err != nil {
			return nil, err
		}
	}
	return val, nil
}

func (i *Interpreter) evalPrimary(p *parser.Primary) (any, error) {
	switch {
	case p.Lit != nil:
		return i.evalLiteral(p.Lit)

	case p.Call != nil:
		return i.evalCall(p.Call)

	case p.Group != nil:
		return i.evalExpr(p.Group)

	case p.FunExpr != nil:
		return closure{Fn: p.FunExpr, Env: i.env.Copy(), FullParams: p.FunExpr.Params}, nil

	case p.Selector != nil:
		val, err := i.env.GetValue(p.Selector.Root)
		if err != nil {
			return nil, errUndefinedVariable(p.Pos, p.Selector.Root)
		}
		for _, field := range p.Selector.Tail {
			obj, ok := val.(map[string]any)
			if !ok {
				return nil, errFieldAccessOnNonObject(p.Pos, field, fmt.Sprintf("%T", val))
			}
			val = obj[field]
		}
		return val, nil

	default:
		return nil, errInvalidPrimaryExpression(p.Pos)
	}
}

func (i *Interpreter) evalLiteral(l *parser.Literal) (any, error) {
	switch {
	case l.Int != nil:
		var n int
		fmt.Sscanf(*l.Int, "%d", &n)
		return n, nil
	case l.Float != nil:
		var f float64
		fmt.Sscanf(*l.Float, "%f", &f)
		return f, nil
	case l.Str != nil:
		return *l.Str, nil
	case l.Bool != nil:
		return *l.Bool == "true", nil
	default:
		return nil, errInvalidLiteral(l.Pos)
	}
}

func (i *Interpreter) evalCall(c *parser.CallExpr) (any, error) {
	if c.Func == "print" {
		var sb strings.Builder
		for _, arg := range c.Args {
			val, err := i.evalExpr(arg)
			if err != nil {
				return nil, err
			}
			fmt.Fprintf(&sb, "%v ", val)
		}
		fmt.Fprintln(i.env.Writer(), strings.TrimSpace(sb.String()))
		return nil, nil
	}

	if fn, ok := i.env.GetFunc(c.Func); ok {
		argCount := len(c.Args)
		paramCount := len(fn.Params)

		if argCount > paramCount {
			return nil, errTooManyFunctionArgs(c.Pos, c.Func, paramCount, argCount)
		}

		if argCount < paramCount {
			applied := make([]any, argCount)
			for idx := range c.Args {
				val, err := i.evalExpr(c.Args[idx])
				if err != nil {
					return nil, err
				}
				applied[idx] = val
			}
			remainingParams := fn.Params[argCount:]
			return closure{
				Fn: &parser.FunExpr{
					Params:    remainingParams,
					BlockBody: fn.Body,
				},
				Env:        i.env.Copy(),
				Args:       applied,
				FullParams: fn.Params,
			}, nil
		}

		child := types.NewEnv(i.env)
		for idx, param := range fn.Params {
			val, err := i.evalExpr(c.Args[idx])
			if err != nil {
				return nil, err
			}
			child.SetValue(param.Name, val)
		}
		old := i.env
		i.env = child
		defer func() { i.env = old }()
		for _, stmt := range fn.Body {
			if err := i.evalStmt(stmt); err != nil {
				if r, ok := err.(returnSignal); ok {
					return r.value, nil
				}
				return nil, err
			}
		}
		return nil, nil
	}

	val, err := i.env.GetValue(c.Func)
	if err == nil {
		if cl, ok := val.(closure); ok {
			totalArgs := len(cl.Args) + len(c.Args)
			fullParamCount := len(cl.FullParams)

			if totalArgs > fullParamCount {
				return nil, errTooManyFunctionArgs(c.Pos, c.Func, fullParamCount, totalArgs)
			}

			allArgs := append([]any{}, cl.Args...)
			for _, arg := range c.Args {
				val, err := i.evalExpr(arg)
				if err != nil {
					return nil, err
				}
				allArgs = append(allArgs, val)
			}

			if totalArgs < fullParamCount {
				return closure{
					Fn: &parser.FunExpr{
						Params:    cl.Fn.Params[totalArgs-len(cl.Args):],
						BlockBody: cl.Fn.BlockBody,
						ExprBody:  cl.Fn.ExprBody,
					},
					Env:        cl.Env,
					Args:       allArgs,
					FullParams: cl.FullParams,
				}, nil
			}

			if len(cl.FullParams) != len(allArgs) {
				return nil, errInternalClosureArgMismatch(c.Pos)
			}

			child := types.NewEnv(cl.Env)
			for idx, param := range cl.FullParams {
				child.SetValue(param.Name, allArgs[idx])
			}

			old := i.env
			i.env = child
			defer func() { i.env = old }()
			if cl.Fn.ExprBody != nil {
				return i.evalExpr(cl.Fn.ExprBody)
			}
			for _, stmt := range cl.Fn.BlockBody {
				if err := i.evalStmt(stmt); err != nil {
					if r, ok := err.(returnSignal); ok {
						return r.value, nil
					}
					return nil, err
				}
			}
			return nil, nil
		}
	}

	return nil, errUndefinedFunctionOrClosure(c.Pos, c.Func)
}

// --- Return ---

type returnSignal struct{ value any }

func (r returnSignal) Error() string { return "return" }

func applyBinary(pos lexer.Position, left any, op string, right any) (any, error) {
	switch l := left.(type) {
	case bool:
		if r, ok := right.(bool); ok {
			switch op {
			case "==":
				return l == r, nil
			case "!=":
				return l != r, nil
			}
		}
	case int:
		if r, ok := right.(int); ok {
			return applyIntBinary(pos, l, op, r)
		}
	case float64:
		if r, ok := right.(float64); ok {
			return applyFloatBinary(pos, l, op, r)
		}
	case string:
		if r, ok := right.(string); ok {
			switch op {
			case "+":
				return l + r, nil
			case "==":
				return l == r, nil
			case "!=":
				return l != r, nil
			}
		}
	}
	return nil, errInvalidOperator(pos, op, fmt.Sprintf("%T", left), fmt.Sprintf("%T", right))
}

func applyIntBinary(pos lexer.Position, l int, op string, r int) (any, error) {
	switch op {
	case "/":
		if r == 0 {
			return nil, errDivisionByZero(pos)
		}
		return l / r, nil
	case "+":
		return l + r, nil
	case "-":
		return l - r, nil
	case "*":
		return l * r, nil
	case "==":
		return l == r, nil
	case "!=":
		return l != r, nil
	case "<":
		return l < r, nil
	case "<=":
		return l <= r, nil
	case ">":
		return l > r, nil
	case ">=":
		return l >= r, nil
	default:
		return nil, errInvalidOperator(pos, op, "int", "int")
	}
}

func applyFloatBinary(pos lexer.Position, l float64, op string, r float64) (any, error) {
	switch op {
	case "/":
		if r == 0 {
			return nil, errDivisionByZero(pos)
		}
		return l / r, nil
	case "+":
		return l + r, nil
	case "-":
		return l - r, nil
	case "*":
		return l * r, nil
	case "==":
		return l == r, nil
	case "!=":
		return l != r, nil
	case "<":
		return l < r, nil
	case "<=":
		return l <= r, nil
	case ">":
		return l > r, nil
	case ">=":
		return l >= r, nil
	default:
		return nil, errInvalidOperator(pos, op, "float", "float")
	}
}

func applyUnary(pos lexer.Position, op string, val any) (any, error) {
	switch op {
	case "-":
		switch v := val.(type) {
		case int:
			return -v, nil
		case float64:
			return -v, nil
		default:
			return nil, errInvalidUnaryOperator(pos, op, fmt.Sprintf("%T", val))
		}
	case "!":
		if b, ok := val.(bool); ok {
			return !b, nil
		}
		return nil, errInvalidUnaryOperator(pos, op, fmt.Sprintf("%T", val))
	default:
		return nil, errUnknownUnaryOperator(pos, op)
	}
}

func truthy(val any) bool {
	switch v := val.(type) {
	case bool:
		return v
	case int:
		return v != 0
	case float64:
		return v != 0
	case string:
		return v != ""
	default:
		return val != nil
	}
}

```


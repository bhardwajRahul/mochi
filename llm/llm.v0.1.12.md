// generated by mochi-run, do not edit

# Mochi Source Files for LLM Ingestion

> Version: `0.1.12`

This document includes all core source files used by the Mochi interpreter and runtime toolchain.

## 📖 Overview

- **cmd/mochi/main.go**: Entry point of the Mochi CLI tool.
- **diagnostic/diagnostic.go**: Structured error reporting with source hints.
- **parser/parser.go**: Top-down recursive descent parser.
- **parser/errors.go**: Parser error handling logic.
- **ast/ast.go**: AST node types.
- **ast/convert.go**: Converts parser output to typed AST.
- **ast/pretty.go**: Pretty-print AST in Lisp-style format.
- **types/env.go**: Type environment and symbol resolution.
- **types/check.go**: Static type checker implementation.
- **types/errors.go**: Type checker error definitions.
- **interpreter/interpreter.go**: Interpreter that executes AST.
- **interpreter/errors.go**: Runtime error types.
- **golden/golden.go**: Shared golden file test framework.

---

## cmd/mochi/main.go

```go
package main

import (
	"fmt"
	"os"

	"github.com/alexflint/go-arg"

	"mochi/ast"
	"mochi/interpreter"
	"mochi/parser"
	"mochi/types"
)

var (
	version   = "dev"     // set via -ldflags "-X main.version=..."
	gitCommit = "unknown" // set via -ldflags "-X main.gitCommit=..."
	buildTime = "unknown" // set via -ldflags "-X main.buildTime=..."
)

type Args struct {
	File     string `arg:"positional" help:"Path to .mochi source file"`
	Run      bool   `arg:"-r,--run" help:"Interpret and execute the program"`
	PrintAST bool   `arg:"--ast" help:"Print the parsed AST in Lisp format"`
	Version  bool   `arg:"--version" help:"Show version and exit"`
}

func main() {
	var args Args
	argParser := arg.MustParse(&args)

	if len(os.Args) == 1 {
		argParser.WriteHelp(os.Stdout)
		os.Exit(0)
	}

	if args.Version {
		printVersion()
		os.Exit(0)
	}

	if args.File == "" {
		fmt.Fprintln(os.Stderr, "error: no input file provided")
		argParser.WriteHelp(os.Stderr)
		os.Exit(1)
	}

	prog, err := parser.Parse(args.File)
	if err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}

	// Type check
	typeEnv := types.NewEnv(nil)
	typeErrors := types.Check(prog, typeEnv)
	if len(typeErrors) > 0 {
		fmt.Fprintln(os.Stderr, "\n== TYPECHECK FAILED ==")
		for i, err := range typeErrors {
			fmt.Fprintf(os.Stderr, "  %2d. %v\n", i+1, err)
		}
		os.Exit(1)
	}

	if args.PrintAST {
		fmt.Println("\n== AST ==")
		tree := ast.FromProgram(prog)
		fmt.Println(tree.String())
	}

	if args.Run {
		fmt.Println("\n== RUNNING ==")
		interp := interpreter.New(prog, typeEnv)
		if err := interp.Run(); err != nil {
			fmt.Fprintf(os.Stderr, "runtime error: %v\n", err)
			os.Exit(1)
		}
	}
}

func printVersion() {
	fmt.Printf("Mochi v%s\n", version)
	fmt.Printf("Git commit: %s\n", gitCommit)
	fmt.Printf("Built at:   %s\n", buildTime)
}

```

## diagnostic/diagnostic.go

```go
package diagnostic

import (
	"fmt"
	"os"
	"strings"

	"github.com/alecthomas/participle/v2/lexer"
)

// --------------------
// 🔧 Global Color Flag
// --------------------

// NoColor controls whether color output is disabled (can be set manually or from env)
var NoColor = os.Getenv("NO_COLOR") != ""

// --------------------
// 🎨 Color Functions
// --------------------

func Red(s string) string {
	if NoColor {
		return s
	}
	return "\033[31m" + s + "\033[0m"
}

func Yellow(s string) string {
	if NoColor {
		return s
	}
	return "\033[33m" + s + "\033[0m"
}

func Gray(s string) string {
	if NoColor {
		return s
	}
	return "\033[90m" + s + "\033[0m"
}

// --------------------
// 🧾 Diagnostic Struct
// --------------------

// Diagnostic represents a structured, position-aware error with helpful context.
type Diagnostic struct {
	Code string         // Error code like "E1001"
	Pos  lexer.Position // File/line/col of error
	Msg  string         // Primary error message
	Help string         // Optional help message (guidance)
}

// Error implements error interface for Diagnostic.
func (d Diagnostic) Error() string {
	return d.Format()
}

// Format renders a multi-line Rust-style diagnostic.
func (d Diagnostic) Format() string {
	src, _ := os.ReadFile(d.Pos.Filename)
	lines := strings.Split(string(src), "\n")

	var line string
	if int(d.Pos.Line) <= len(lines) && d.Pos.Line > 0 {
		line = lines[d.Pos.Line-1]
	}

	marker := strings.Repeat(" ", int(d.Pos.Column)-1) + "^"

	out := []string{
		fmt.Sprintf("%s: %s", Red("error["+d.Code+"]"), d.Msg),
		fmt.Sprintf("  --> %s:%d:%d", d.Pos.Filename, d.Pos.Line, d.Pos.Column),
	}

	if line != "" {
		out = append(out, "",
			fmt.Sprintf("%s | %s", Gray(fmt.Sprintf("%3d", d.Pos.Line)), line),
			fmt.Sprintf("    | %s", Red(marker)),
		)
	}

	if d.Help != "" {
		out = append(out, "", Yellow("help:"), "  "+d.Help)
	}

	return strings.Join(out, "\n")
}

// --------------------
// ✨ Constructor Helpers
// --------------------

// New returns a new Diagnostic instance.
func New(code string, pos lexer.Position, msg, help string) Diagnostic {
	return Diagnostic{
		Code: code,
		Pos:  pos,
		Msg:  msg,
		Help: help,
	}
}

// Wrap creates an error interface from New (shorthand).
func Wrap(code string, pos lexer.Position, msg, help string) error {
	return New(code, pos, msg, help)
}

```

## parser/parser.go

```go
package parser

import (
	"github.com/alecthomas/participle/v2"
	"github.com/alecthomas/participle/v2/lexer"
)

// --- Mochi Lexer ---
var mochiLexer = lexer.MustSimple([]lexer.SimpleRule{
	// Combined line and block comment support
	{Name: "Comment", Pattern: `//[^\n]*|/\*([^*]|\*+[^*/])*\*+/`},
	{Name: "Bool", Pattern: `\b(true|false)\b`},
	{Name: "Ident", Pattern: `[a-zA-Z_][a-zA-Z0-9_]*`},
	{Name: "Float", Pattern: `\d+\.\d+`},
	{Name: "Int", Pattern: `\d+`},
	{Name: "String", Pattern: `"(?:\\.|[^"])*"`},
	{Name: "Punct", Pattern: `==|!=|<=|>=|=>|\.\.|[-+*/=<>!{}(),.:]`},
	{Name: "Whitespace", Pattern: `[ \t\n\r]+`},
})

// --- Program Structure ---

type Program struct {
	Pos        lexer.Position
	Statements []*Statement `parser:"@@*"`
}

type Statement struct {
	Test   *TestBlock  `parser:"@@"`
	Expect *ExpectStmt `parser:"| @@"`
	Agent  *AgentDecl  `parser:"| @@"`
	Stream *StreamDecl `parser:"| @@"`
	On     *OnHandler  `parser:"| @@"`
	Let    *LetStmt    `parser:"| @@"`
	Assign *AssignStmt `parser:"| @@"`
	Fun    *FunStmt    `parser:"| @@"`
	Return *ReturnStmt `parser:"| @@"`
	If     *IfStmt     `parser:"| @@"`
	For    *ForStmt    `parser:"| @@"`
	Expr   *ExprStmt   `parser:"| @@"`
}

// --- Test and Expect ---

type TestBlock struct {
	Pos  lexer.Position
	Test string       `parser:"'test'"`
	Name string       `parser:"@String"`
	Body []*Statement `parser:"'{' @@* '}'"`
}

type ExpectStmt struct {
	Pos    lexer.Position
	Expect string `parser:"'expect'"`
	Value  *Expr  `parser:"@@"`
}

// --- If Statement ---

type IfStmt struct {
	Pos    lexer.Position
	If     string       `parser:"'if'"`
	Cond   *Expr        `parser:"@@"`
	Then   []*Statement `parser:"'{' @@* '}'"`
	ElseIf *IfStmt      `parser:"[ 'else' @@"`
	Else   []*Statement `parser:"| 'else' '{' @@* '}' ]"`
}

// --- For Statement ---

type ForStmt struct {
	Pos   lexer.Position
	For   string       `parser:"'for'"`
	Name  string       `parser:"@Ident"`
	In    string       `parser:"'in'"`
	Start *Expr        `parser:"@@"`
	Dots  string       `parser:"'..'"`
	End   *Expr        `parser:"@@"`
	Body  []*Statement `parser:"'{' @@* '}'"`
}

// --- Type System ---

type TypeRef struct {
	Fun    *FunType `parser:"@@"`
	Simple *string  `parser:"| @Ident"`
}

type FunType struct {
	Fun    string     `parser:"'fun'"`
	Params []*TypeRef `parser:"'(' [ @@ { ',' @@ } ] ')'"`
	Return *TypeRef   `parser:"[ ':' @@ ]"`
}

// --- Declarations & Statements ---

type LetStmt struct {
	Pos   lexer.Position
	Let   string   `parser:"'let'"`
	Name  string   `parser:"@Ident"`
	Type  *TypeRef `parser:"[ ':' @@ ]"`
	Value *Expr    `parser:"[ '=' @@ ]"`
}

type AssignStmt struct {
	Pos   lexer.Position
	Name  string `parser:"@Ident"`
	Eq    string `parser:"'='"`
	Value *Expr  `parser:"@@"`
}

type FunStmt struct {
	Pos    lexer.Position
	Fun    string       `parser:"'fun'"`
	Name   string       `parser:"@Ident"`
	Params []*Param     `parser:"'(' [ @@ { ',' @@ } ] ')'"`
	Return *TypeRef     `parser:"[ ':' @@ ]"`
	Body   []*Statement `parser:"'{' @@* '}'"`
}

type ReturnStmt struct {
	Pos   lexer.Position
	Ret   string `parser:"'return'"`
	Value *Expr  `parser:"@@"`
}

type Param struct {
	Name string   `parser:"@Ident"`
	Type *TypeRef `parser:"[ ':' @@ ]"`
}

type ExprStmt struct {
	Pos  lexer.Position
	Expr *Expr `parser:"@@"`
}

// --- Expressions ---

type Expr struct {
	Pos      lexer.Position
	Equality *Equality `parser:"@@"`
}

type Equality struct {
	Left  *Comparison `parser:"@@"`
	Right []*EqualOp  `parser:"@@*"`
}

type EqualOp struct {
	Pos   lexer.Position
	Op    string      `parser:"@('==' | '!=')"`
	Right *Comparison `parser:"@@"`
}

type Comparison struct {
	Left  *Term     `parser:"@@"`
	Right []*CompOp `parser:"@@*"`
}

type CompOp struct {
	Pos   lexer.Position
	Op    string `parser:"@('<' | '<=' | '>' | '>=')"`
	Right *Term  `parser:"@@"`
}

type Term struct {
	Left  *Factor   `parser:"@@"`
	Right []*TermOp `parser:"@@*"`
}

type TermOp struct {
	Pos   lexer.Position
	Op    string  `parser:"@('+' | '-')"`
	Right *Factor `parser:"@@"`
}

type Factor struct {
	Left  *Unary      `parser:"@@"`
	Right []*FactorOp `parser:"@@*"`
}

type FactorOp struct {
	Pos   lexer.Position
	Op    string `parser:"@('*' | '/')"`
	Right *Unary `parser:"@@"`
}

type Unary struct {
	Pos   lexer.Position
	Ops   []string `parser:"{@('-' | '!')}"`
	Value *Primary `parser:"@@"`
}

type Primary struct {
	Pos      lexer.Position
	FunExpr  *FunExpr      `parser:"@@"`
	Call     *CallExpr     `parser:"| @@"`
	Selector *SelectorExpr `parser:"| @@"`
	Lit      *Literal      `parser:"| @@"`
	Group    *Expr         `parser:"| '(' @@ ')'"`
}

type FunExpr struct {
	Pos       lexer.Position
	Fun       string       `parser:"'fun'"`
	Params    []*Param     `parser:"'(' [ @@ { ',' @@ } ] ')'"`
	Return    *TypeRef     `parser:"[ ':' @@ ]"`
	Arrow     string       `parser:"'=>'"`
	ExprBody  *Expr        `parser:"@@"`
	BlockBody []*Statement `parser:"| '{' @@* '}'"`
}

// --- Atoms ---

type SelectorExpr struct {
	Root string   `parser:"@Ident"`
	Tail []string `parser:"{ '.' @Ident }"`
}

type CallExpr struct {
	Pos    lexer.Position
	Func   string  `parser:"@Ident '('"`
	Args   []*Expr `parser:"[ @@ { ',' @@ } ]"`
	RParen string  `parser:"')'"`
}

type Literal struct {
	Pos   lexer.Position
	Float *float64 `parser:"@Float"`
	Int   *int     `parser:"| @Int"`
	Bool  *bool    `parser:"| @(\"true\" | \"false\")"`
	Str   *string  `parser:"| @String"`
}

// --- Stream / Struct Declarations ---

type StreamDecl struct {
	Pos    lexer.Position
	Stream string         `parser:"'stream'"`
	Name   string         `parser:"@Ident"`
	Fields []*StreamField `parser:"'{' @@* '}'"`
}

type StreamField struct {
	Nested *StreamNestedField `parser:"@@"`
	Simple *StreamSimpleField `parser:"| @@"`
}

type StreamSimpleField struct {
	Name string `parser:"@Ident"`
	Type string `parser:"':' @Ident"`
}

type StreamNestedField struct {
	Name string     `parser:"@Ident"`
	Type string     `parser:"':'"`
	Body *StructDef `parser:"@@"`
}

type StructDef struct {
	LBrace string         `parser:"'{'"`
	Fields []*StreamField `parser:"@@*"`
	RBrace string         `parser:"'}'"`
}

// --- On Handler ---

type OnHandler struct {
	Pos    lexer.Position
	On     string       `parser:"'on'"`
	Stream string       `parser:"@Ident"`
	As     string       `parser:"'as'"`
	Alias  string       `parser:"@Ident"`
	Body   []*Statement `parser:"'{' @@* '}'"`
}

// --- Agent DSL ---

type AgentDecl struct {
	Pos   lexer.Position
	Agent string        `parser:"'agent'"`
	Name  string        `parser:"@Ident"`
	Body  []*AgentBlock `parser:"'{' @@* '}'"`
}

type AgentBlock struct {
	Let    *LetStmt    `parser:"@@"`
	Assign *AssignStmt `parser:"| @@"`
	On     *OnHandler  `parser:"| @@"`
	Intent *IntentDecl `parser:"| @@"`
}

type IntentDecl struct {
	Pos    lexer.Position
	Intent string       `parser:"'intent'"`
	Name   string       `parser:"@Ident"`
	Params []*Param     `parser:"'(' [ @@ { ',' @@ } ] ')'"`
	Return *TypeRef     `parser:"[ ':' @@ ]"`
	Body   []*Statement `parser:"'{' @@* '}'"`
}

// --- Parser Instance ---

var Parser = participle.MustBuild[Program](
	participle.Lexer(mochiLexer),
	participle.Elide("Whitespace", "Comment"),
	participle.Unquote("String"),
	participle.UseLookahead(999),
)

```

## parser/errors.go

```go
package parser

import (
	"errors"
	"os"
	"strings"

	"github.com/alecthomas/participle/v2/lexer"
	"mochi/diagnostic"
)

// Parse loads and parses a Mochi source file.
func Parse(path string) (*Program, error) {
	src, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}

	prog, err := Parser.ParseString(path, string(src))
	if err != nil {
		return nil, wrapParseError(path, err)
	}
	return prog, nil
}

// wrapParseError upgrades raw participle errors into structured diagnostics.
func wrapParseError(filename string, err error) error {
	var posErr interface{ Position() lexer.Position }
	if !errors.As(err, &posErr) {
		return err
	}
	pos := posErr.Position()
	code, help := suggestFix(err.Error())
	return diagnostic.New(code, pos, err.Error(), help)
}

// suggestFix returns a (diagnosticCode, helpText) pair for known parsing errors.
func suggestFix(msg string) (string, string) {
	msg = strings.ToLower(msg)

	switch {
	// --- Block and EOF Errors ---
	case containsAny(msg, `expected "}"`, `expected "{"`, "unexpected eof"):
		return "P001", "Check for a missing `{` or `}` to close the block."

	case strings.Contains(msg, "unexpected eof"):
		return "P002", "Expression or closing delimiter might be missing."

	// --- Function Body Errors ---
	case strings.Contains(msg, `expected "{" statement* "}"`):
		return "P010", "Function bodies must be enclosed in `{ ... }`."

	case containsAll(msg, "expected", `"{"`, "=>"):
		return "P011", "`=>` cannot replace a full `{}` block in function bodies."

	// --- Expression Errors ---
	case containsAny(msg, "expected expression", "expected primary"):
		return "P020", "An expression was expected here. Check syntax."

	// --- Variable & Identifier Issues ---
	case strings.Contains(msg, "expected identifier"):
		return "P030", "A variable or function name is required."

	case containsAll(msg, `unexpected token ":"`, "let"):
		return "P031", "`let` must be followed by a variable name."

	// --- String and Literal Errors ---
	case containsAny(msg, "unterminated string", "invalid input text", `"unterminated`):
		return "P040", "String literals must be properly closed with a `\"`."

	// --- Punctuation Errors ---
	case containsAll(msg, `unexpected token "*"`, "expected primary"):
		return "P050", "`*` is not allowed here. Did you mean to multiply? Use full expression."

	case strings.Contains(msg, `expected ","`):
		return "P051", "Separate function arguments or list elements with commas."

	case containsAny(msg, `expected "("`, `expected ")"`):
		return "P052", "Unbalanced parentheses. Check for missing `(` or `)`."

	case containsAll(msg, `unexpected token "}"`, "expected expression"):
		return "P053", "`}` found unexpectedly. Check for incomplete expression."

	case containsAll(msg, `unexpected token ":"`, `expected ")"`, `"{"`):
		return "P054", "Check for misused colon. Function parameters must use correct syntax: (name: type)."

	case strings.Contains(msg, `unexpected token "."`):
		return "P055", "Stray `.` dot — expected a selector after it. Did you forget an identifier?"

	case strings.Contains(msg, `unexpected token "let"`):
		return "P056", "Unexpected `let` — remove redundant declaration keyword."

	// --- Unknown or Unclassified ---
	default:
		return "P999", "Parse error occurred. Check syntax near this location."
	}
}

// containsAll returns true if all substrings appear in s.
func containsAll(s string, parts ...string) bool {
	for _, p := range parts {
		if !strings.Contains(s, p) {
			return false
		}
	}
	return true
}

// containsAny returns true if any substring appears in s.
func containsAny(s string, parts ...string) bool {
	for _, p := range parts {
		if strings.Contains(s, p) {
			return true
		}
	}
	return false
}

/*
var reserved = map[string]struct{}{
	"let": {}, "fun": {}, "if": {}, "else": {}, "for": {}, "return": {},
	"true": {}, "false": {}, "stream": {}, "agent": {}, "test": {}, "expect": {},
	"on": {}, "intent": {},
}

func isReserved(name string) bool {
	_, found := reserved[name]
	return found
}
*/

```

## ast/ast.go

```go
package ast

import (
	"fmt"
	"regexp"
	"strings"
)

// Node is a simplified, uniform AST representation (inspired by Lisp)
type Node struct {
	Kind     string
	Value    any
	Children []*Node
}

// Print writes a compact Lisp-like tree to stdout
func (n *Node) Print(indent string) {
	fmt.Print(n.String())
}

// String returns the pretty-printed AST as a compact Lisp-like string
func (n *Node) String() string {
	var b strings.Builder
	write(&b, n, "")
	b.WriteString("\n")
	return b.String()
}

// write is a helper to recursively pretty-print the AST
func write(b *strings.Builder, n *Node, indent string) {
	b.WriteString(indent + "(" + n.Kind)
	if n.Value != nil {
		b.WriteString(" " + formatValue(n.Value))
	}

	if len(n.Children) == 0 {
		b.WriteString(")")
		return
	}

	// Check if all children are leaf nodes
	allLeaf := true
	for _, c := range n.Children {
		if len(c.Children) > 0 {
			allLeaf = false
			break
		}
	}

	if allLeaf {
		for _, c := range n.Children {
			b.WriteString(" (" + c.Kind)
			if c.Value != nil {
				b.WriteString(" " + formatValue(c.Value))
			}
			b.WriteString(")")
		}
		b.WriteString(")")
	} else {
		b.WriteString("\n")
		for _, c := range n.Children {
			write(b, c, indent+"  ")
			b.WriteString("\n")
		}
		b.WriteString(indent + ")")
	}
}

// safeIdent matches values that don't need quoting in AST output.
// Now includes common operators.
var safeIdent = regexp.MustCompile(`^[a-zA-Z0-9._\-+=*/<>!%&|^~]+$`)

// formatValue returns a string representation of a value,
// quoting only if necessary.
func formatValue(v any) string {
	switch s := v.(type) {
	case string:
		if safeIdent.MatchString(s) {
			return s
		}
		return fmt.Sprintf("%q", s)
	default:
		return fmt.Sprintf("%v", v)
	}
}

```

## ast/convert.go

```go
package ast

import "mochi/parser"

// FromProgram converts a parsed Program into an AST Node tree.
func FromProgram(p *parser.Program) *Node {
	root := &Node{Kind: "program"}
	for _, stmt := range p.Statements {
		root.Children = append(root.Children, FromStatement(stmt))
	}
	return root
}

// FromStatement converts a top-level Statement into a Node.
func FromStatement(s *parser.Statement) *Node {
	switch {
	case s.Let != nil:
		n := &Node{
			Kind:  "let",
			Value: s.Let.Name,
		}
		if s.Let.Type != nil {
			n.Children = append(n.Children, FromTypeRef(s.Let.Type))
		}
		if s.Let.Value != nil {
			n.Children = append(n.Children, FromExpr(s.Let.Value))
		}
		return n

	case s.Assign != nil:
		return &Node{
			Kind:  "assign",
			Value: s.Assign.Name,
			Children: []*Node{
				FromExpr(s.Assign.Value),
			},
		}

	case s.Fun != nil:
		n := &Node{Kind: "fun", Value: s.Fun.Name}
		for _, param := range s.Fun.Params {
			paramNode := &Node{Kind: "param", Value: param.Name}
			if param.Type != nil {
				paramNode.Children = append(paramNode.Children, FromTypeRef(param.Type))
			}
			n.Children = append(n.Children, paramNode)
		}
		if s.Fun.Return != nil {
			n.Children = append(n.Children, FromTypeRef(s.Fun.Return))
		}
		for _, stmt := range s.Fun.Body {
			n.Children = append(n.Children, FromStatement(stmt))
		}
		return n

	case s.Return != nil:
		return &Node{Kind: "return", Children: []*Node{FromExpr(s.Return.Value)}}

	case s.Expr != nil:
		return &Node{Kind: "exprstmt", Children: []*Node{FromExpr(s.Expr.Expr)}}

	case s.If != nil:
		return fromIfStmt(s.If)

	case s.For != nil:
		return fromForStmt(s.For)

	case s.Agent != nil:
		n := &Node{Kind: "agent", Value: s.Agent.Name}
		for _, block := range s.Agent.Body {
			switch {
			case block.Let != nil:
				n.Children = append(n.Children, FromStatement(&parser.Statement{Let: block.Let}))
			case block.Assign != nil:
				n.Children = append(n.Children, FromStatement(&parser.Statement{Assign: block.Assign}))
			case block.On != nil:
				n.Children = append(n.Children, fromOnHandler(block.On))
			case block.Intent != nil:
				n.Children = append(n.Children, fromIntent(block.Intent))
			}
		}
		return n

	case s.On != nil:
		return fromOnHandler(s.On)

	case s.Stream != nil:
		n := &Node{Kind: "stream", Value: s.Stream.Name}
		for _, field := range s.Stream.Fields {
			n.Children = append(n.Children, fromStreamField(field))
		}
		return n

	case s.Test != nil:
		n := &Node{Kind: "test", Value: s.Test.Name}
		for _, stmt := range s.Test.Body {
			n.Children = append(n.Children, FromStatement(stmt))
		}
		return n

	case s.Expect != nil:
		return &Node{Kind: "expect", Children: []*Node{FromExpr(s.Expect.Value)}}

	default:
		return &Node{Kind: "unknown"}
	}
}

func fromIfStmt(stmt *parser.IfStmt) *Node {
	n := &Node{Kind: "if"}
	n.Children = append(n.Children, FromExpr(stmt.Cond))
	thenBlock := &Node{Kind: "block"}
	for _, stmt := range stmt.Then {
		thenBlock.Children = append(thenBlock.Children, FromStatement(stmt))
	}
	n.Children = append(n.Children, thenBlock)

	if stmt.ElseIf != nil {
		n.Children = append(n.Children, fromIfStmt(stmt.ElseIf))
	} else if stmt.Else != nil {
		elseBlock := &Node{Kind: "block"}
		for _, stmt := range stmt.Else {
			elseBlock.Children = append(elseBlock.Children, FromStatement(stmt))
		}
		n.Children = append(n.Children, elseBlock)
	}

	return n
}

func fromForStmt(f *parser.ForStmt) *Node {
	return &Node{
		Kind:  "for",
		Value: f.Name,
		Children: []*Node{
			{Kind: "range", Children: []*Node{
				FromExpr(f.Start),
				FromExpr(f.End),
			}},
			{Kind: "block", Children: mapStatements(f.Body)},
		},
	}
}

func mapStatements(stmts []*parser.Statement) []*Node {
	var out []*Node
	for _, s := range stmts {
		out = append(out, FromStatement(s))
	}
	return out
}

func fromOnHandler(h *parser.OnHandler) *Node {
	n := &Node{Kind: "on", Value: h.Stream}
	for _, stmt := range h.Body {
		n.Children = append(n.Children, FromStatement(stmt))
	}
	return n
}

func fromIntent(i *parser.IntentDecl) *Node {
	n := &Node{Kind: "intent", Value: i.Name}
	for _, param := range i.Params {
		paramNode := &Node{Kind: "param", Value: param.Name}
		if param.Type != nil {
			paramNode.Children = append(paramNode.Children, FromTypeRef(param.Type))
		}
		n.Children = append(n.Children, paramNode)
	}
	if i.Return != nil {
		n.Children = append(n.Children, FromTypeRef(i.Return))
	}
	for _, stmt := range i.Body {
		n.Children = append(n.Children, FromStatement(stmt))
	}
	return n
}

func fromStreamField(f *parser.StreamField) *Node {
	if f.Simple != nil {
		return &Node{
			Kind:  "field",
			Value: f.Simple.Name + ":" + f.Simple.Type,
		}
	}
	if f.Nested != nil {
		n := &Node{
			Kind:  "field",
			Value: f.Nested.Name + ":" + f.Nested.Type,
		}
		for _, sf := range f.Nested.Body.Fields {
			n.Children = append(n.Children, fromStreamField(sf))
		}
		return n
	}
	return &Node{Kind: "field"}
}

// FromExpr converts a high-level expression.
func FromExpr(e *parser.Expr) *Node {
	return FromEquality(e.Equality)
}

func FromEquality(e *parser.Equality) *Node {
	n := FromComparison(e.Left)
	for _, op := range e.Right {
		n = &Node{Kind: "binary", Value: op.Op, Children: []*Node{n, FromComparison(op.Right)}}
	}
	return n
}

func FromComparison(c *parser.Comparison) *Node {
	n := FromTerm(c.Left)
	for _, op := range c.Right {
		n = &Node{Kind: "binary", Value: op.Op, Children: []*Node{n, FromTerm(op.Right)}}
	}
	return n
}

func FromTerm(t *parser.Term) *Node {
	n := FromFactor(t.Left)
	for _, op := range t.Right {
		n = &Node{Kind: "binary", Value: op.Op, Children: []*Node{n, FromFactor(op.Right)}}
	}
	return n
}

func FromFactor(f *parser.Factor) *Node {
	n := FromUnary(f.Left)
	for _, op := range f.Right {
		n = &Node{Kind: "binary", Value: op.Op, Children: []*Node{n, FromUnary(op.Right)}}
	}
	return n
}

func FromUnary(u *parser.Unary) *Node {
	n := FromPrimary(u.Value)
	for i := len(u.Ops) - 1; i >= 0; i-- {
		n = &Node{Kind: "unary", Value: u.Ops[i], Children: []*Node{n}}
	}
	return n
}

func FromPrimary(p *parser.Primary) *Node {
	switch {
	case p.FunExpr != nil:
		n := &Node{Kind: "funexpr"}
		for _, param := range p.FunExpr.Params {
			paramNode := &Node{Kind: "param", Value: param.Name}
			if param.Type != nil {
				paramNode.Children = append(paramNode.Children, FromTypeRef(param.Type))
			}
			n.Children = append(n.Children, paramNode)
		}
		if p.FunExpr.Return != nil {
			n.Children = append(n.Children, FromTypeRef(p.FunExpr.Return))
		}
		if p.FunExpr.ExprBody != nil {
			n.Children = append(n.Children, FromExpr(p.FunExpr.ExprBody))
		} else if len(p.FunExpr.BlockBody) > 0 {
			block := &Node{Kind: "block"}
			for _, stmt := range p.FunExpr.BlockBody {
				block.Children = append(block.Children, FromStatement(stmt))
			}
			n.Children = append(n.Children, block)
		}
		return n

	case p.Call != nil:
		n := &Node{Kind: "call", Value: p.Call.Func}
		for _, arg := range p.Call.Args {
			n.Children = append(n.Children, FromExpr(arg))
		}
		return n

	case p.Selector != nil:
		n := &Node{Kind: "selector", Value: p.Selector.Root}
		for _, field := range p.Selector.Tail {
			n = &Node{Kind: "selector", Value: field, Children: []*Node{n}}
		}
		return n

	case p.Lit != nil:
		switch {
		case p.Lit.Float != nil:
			return &Node{Kind: "float", Value: *p.Lit.Float}
		case p.Lit.Int != nil:
			return &Node{Kind: "int", Value: *p.Lit.Int}
		case p.Lit.Str != nil:
			return &Node{Kind: "string", Value: *p.Lit.Str}
		case p.Lit.Bool != nil:
			return &Node{Kind: "bool", Value: *p.Lit.Bool}
		}

	case p.Group != nil:
		return &Node{Kind: "group", Children: []*Node{FromExpr(p.Group)}}
	}
	return &Node{Kind: "unknown"}
}

// FromTypeRef converts a TypeRef (including function types) to a Node.
func FromTypeRef(t *parser.TypeRef) *Node {
	if t == nil {
		return nil
	}
	if t.Fun != nil {
		n := &Node{Kind: "typefun"}
		for _, param := range t.Fun.Params {
			n.Children = append(n.Children, FromTypeRef(param))
		}
		if t.Fun.Return != nil {
			n.Children = append(n.Children, FromTypeRef(t.Fun.Return))
		}
		return n
	}
	return &Node{Kind: "type", Value: *t.Simple}
}

```

## ast/pretty.go

```go
package ast

import (
	"fmt"

	"mochi/parser"
)

// PrettyStatement returns a readable description of a statement, including its source position.
func PrettyStatement(s *parser.Statement) string {
	switch {
	case s.Let != nil:
		return fmt.Sprintf("%s: let %s", s.Let.Pos, s.Let.Name)

	case s.Assign != nil:
		return fmt.Sprintf("%s: %s = ...", s.Assign.Pos, s.Assign.Name)

	case s.Fun != nil:
		return fmt.Sprintf("%s: fun %s(%d params)", s.Fun.Pos, s.Fun.Name, len(s.Fun.Params))

	case s.Expr != nil:
		return fmt.Sprintf("%s: expression", s.Expr.Pos)

	case s.Return != nil:
		return fmt.Sprintf("%s: return ...", s.Return.Pos)

	case s.If != nil:
		return fmt.Sprintf("%s: if ...", s.If.Pos)

	case s.For != nil:
		return fmt.Sprintf("%s: for %s in ...", s.For.Pos, s.For.Name)

	case s.On != nil:
		return fmt.Sprintf("%s: on %s as %s", s.On.Pos, s.On.Stream, s.On.Alias)

	case s.Agent != nil:
		return fmt.Sprintf("%s: agent %s", s.Agent.Pos, s.Agent.Name)

	case s.Stream != nil:
		return fmt.Sprintf("%s: stream %s", s.Stream.Pos, s.Stream.Name)

	case s.Test != nil:
		return fmt.Sprintf("%s: test %s", s.Test.Pos, s.Test.Name)

	case s.Expect != nil:
		return fmt.Sprintf("%s: expect %v", s.Expect.Pos, s.Expect.Value)

	default:
		return "unknown statement"
	}
}

```

## types/env.go

```go
package types

import (
	"fmt"
	"io"
	"mochi/parser"
	"os"
)

// Env holds both type and value bindings for variables and functions.
type Env struct {
	parent *Env

	types  map[string]Type            // static types
	values map[string]any             // runtime values
	funcs  map[string]*parser.FunStmt // function declarations

	output io.Writer // default: os.Stdout
}

// NewEnv creates a new lexical scope environment.
func NewEnv(parent *Env) *Env {
	return &Env{
		parent: parent,
		types:  make(map[string]Type),
		values: make(map[string]any),
		funcs:  make(map[string]*parser.FunStmt),
		output: os.Stdout,
	}
}

// --- Type (Static) Binding ---

// SetVar defines a variable's static type.
func (e *Env) SetVar(name string, typ Type) {
	e.types[name] = typ
}

// GetVar looks up a variable's static type.
func (e *Env) GetVar(name string) (Type, error) {
	if t, ok := e.types[name]; ok {
		return t, nil
	}
	if e.parent != nil {
		return e.parent.GetVar(name)
	}
	return nil, fmt.Errorf("undefined variable: %s", name)
}

// --- Value (Runtime) Binding ---

// SetValue sets a variable's runtime value.
func (e *Env) SetValue(name string, val any) {
	e.values[name] = val
}

// UpdateValue modifies an existing variable's runtime value.
func (e *Env) UpdateValue(name string, val any) error {
	if _, ok := e.values[name]; ok {
		e.values[name] = val
		return nil
	}
	if e.parent != nil {
		return e.parent.UpdateValue(name, val)
	}
	return fmt.Errorf("variable not declared: %s", name)
}

// GetValue retrieves a runtime value.
func (e *Env) GetValue(name string) (any, error) {
	if val, ok := e.values[name]; ok {
		return val, nil
	}
	if e.parent != nil {
		return e.parent.GetValue(name)
	}
	return nil, fmt.Errorf("undefined variable: %s", name)
}

// --- Function Binding ---

// SetFunc binds a named function.
func (e *Env) SetFunc(name string, fn *parser.FunStmt) {
	e.funcs[name] = fn
}

// SetFuncType binds a function name to its static type.
func (e *Env) SetFuncType(name string, typ Type) {
	e.types[name] = typ
}

// GetFunc retrieves a function definition.
func (e *Env) GetFunc(name string) (*parser.FunStmt, bool) {
	if fn, ok := e.funcs[name]; ok {
		return fn, true
	}
	if e.parent != nil {
		return e.parent.GetFunc(name)
	}
	return nil, false
}

// Copy creates a shallow copy of the current environment with no parent.
// Useful for closures capturing current bindings.
func (e *Env) Copy() *Env {
	newEnv := &Env{
		parent: nil, // flatten parent chain
		types:  make(map[string]Type, len(e.types)),
		values: make(map[string]any, len(e.values)),
		funcs:  make(map[string]*parser.FunStmt, len(e.funcs)),
		output: e.output,
	}
	for k, v := range e.types {
		newEnv.types[k] = v
	}
	for k, v := range e.values {
		newEnv.values[k] = v
	}
	for k, v := range e.funcs {
		newEnv.funcs[k] = v
	}
	return newEnv
}

// --- Output Control ---

// SetWriter sets the output destination.
func (e *Env) SetWriter(w io.Writer) {
	e.output = w
}

// Writer returns the current output writer.
func (e *Env) Writer() io.Writer {
	return e.output
}

```

## types/check.go

```go
package types

import (
	"fmt"

	"github.com/alecthomas/participle/v2/lexer"
	"mochi/parser"
)

// --- Type System ---

type Type interface {
	String() string
	Equal(Type) bool
}

type IntType struct{}

func (IntType) String() string    { return "int" }
func (IntType) Equal(t Type) bool { _, ok := t.(IntType); return ok }

type FloatType struct{}

func (FloatType) String() string    { return "float" }
func (FloatType) Equal(t Type) bool { _, ok := t.(FloatType); return ok }

type StringType struct{}

func (StringType) String() string    { return "string" }
func (StringType) Equal(t Type) bool { _, ok := t.(StringType); return ok }

type BoolType struct{}

func (BoolType) String() string    { return "bool" }
func (BoolType) Equal(t Type) bool { _, ok := t.(BoolType); return ok }

type VoidType struct{}

func (VoidType) String() string    { return "void" }
func (VoidType) Equal(t Type) bool { _, ok := t.(VoidType); return ok }

type AnyType struct{}

func (AnyType) String() string    { return "any" }
func (AnyType) Equal(t Type) bool { return true }

type TypeVar struct {
	Name string
}

func (t *TypeVar) String() string { return t.Name }
func (t *TypeVar) Equal(other Type) bool {
	if o, ok := other.(*TypeVar); ok {
		return t.Name == o.Name
	}
	return false
}

type FuncType struct {
	Params []Type
	Return Type
}

func (f FuncType) String() string {
	s := "fun("
	for i, p := range f.Params {
		if i > 0 {
			s += ", "
		}
		s += p.String()
	}
	s += ")"
	if f.Return != nil && f.Return.String() != "void" {
		s += ": " + f.Return.String()
	}
	return s
}
func (f FuncType) Equal(t Type) bool {
	other, ok := t.(FuncType)
	if !ok || len(f.Params) != len(other.Params) {
		return false
	}
	for i := range f.Params {
		if !f.Params[i].Equal(other.Params[i]) {
			return false
		}
	}
	return f.Return.Equal(other.Return)
}

type BuiltinFuncType struct{}

func (BuiltinFuncType) String() string    { return "fun(...): void" }
func (BuiltinFuncType) Equal(t Type) bool { _, ok := t.(BuiltinFuncType); return ok }

// --- Entry Point ---

func Check(prog *parser.Program, env *Env) []error {
	env.SetVar("print", BuiltinFuncType{})
	var errs []error
	for _, stmt := range prog.Statements {
		if err := checkStmt(stmt, env, VoidType{}); err != nil {
			errs = append(errs, err)
		}
	}
	return errs
}

// --- Helpers ---

func checkStmt(s *parser.Statement, env *Env, expectedReturn Type) error {
	switch {
	case s.Let != nil:
		name := s.Let.Name
		var typ Type
		if s.Let.Type != nil {
			typ = resolveTypeRef(s.Let.Type)
			if s.Let.Value != nil {
				exprType, err := checkExprWithExpected(s.Let.Value, env, typ)
				if err != nil {
					return err
				}
				if !typ.Equal(exprType) {
					return errTypeMismatch(s.Let.Pos, typ, exprType)
				}
			}
		} else if s.Let.Value != nil {
			var err error
			typ, err = checkExprWithExpected(s.Let.Value, env, nil)
			if err != nil {
				return err
			}
		} else {
			return errLetMissingTypeOrValue(s.Let.Pos)
		}
		env.SetVar(name, typ)
		return nil

	case s.Assign != nil:
		rhsType, err := checkExprWithExpected(s.Assign.Value, env, nil)
		if err != nil {
			return err
		}
		lhsType, err := env.GetVar(s.Assign.Name)
		if err != nil {
			return errAssignUndeclared(s.Assign.Pos, s.Assign.Name)
		}
		if !lhsType.Equal(rhsType) {
			return errCannotAssign(s.Assign.Pos, rhsType, s.Assign.Name, lhsType)
		}
		return nil

	case s.Fun != nil:
		name := s.Fun.Name
		params := []Type{}
		for _, p := range s.Fun.Params {
			if p.Type == nil {
				return errParamMissingType(s.Fun.Pos, p.Name)
			}
			params = append(params, resolveTypeRef(p.Type))
		}
		var ret Type = VoidType{}
		if s.Fun.Return != nil {
			ret = resolveTypeRef(s.Fun.Return)
		}
		env.SetVar(name, FuncType{Params: params, Return: ret})

		child := NewEnv(env)
		for i, p := range s.Fun.Params {
			child.SetVar(p.Name, params[i])
		}
		for _, stmt := range s.Fun.Body {
			if err := checkStmt(stmt, child, ret); err != nil {
				return err
			}
		}
		return nil

	case s.Expr != nil:
		_, err := checkExprWithExpected(s.Expr.Expr, env, nil)
		return err

	case s.Return != nil:
		actual, err := checkExprWithExpected(s.Return.Value, env, expectedReturn)
		if err != nil {
			return err
		}
		if !actual.Equal(expectedReturn) {
			return errReturnMismatch(s.Return.Pos, expectedReturn, actual)
		}
		return nil

	case s.Test != nil:
		child := NewEnv(env)
		for _, stmt := range s.Test.Body {
			if err := checkStmt(stmt, child, expectedReturn); err != nil {
				return err
			}
		}
		return nil

	case s.Expect != nil:
		t, err := checkExprWithExpected(s.Expect.Value, env, BoolType{})
		if err != nil {
			return err
		}
		if !t.Equal(BoolType{}) {
			return errExpectBoolean(s.Expect.Pos)
		}
		return nil
	}
	return nil
}

func resolveTypeRef(t *parser.TypeRef) Type {
	if t.Fun != nil {
		params := make([]Type, len(t.Fun.Params))
		for i, p := range t.Fun.Params {
			params[i] = resolveTypeRef(p)
		}
		var ret Type = VoidType{}
		if t.Fun.Return != nil {
			ret = resolveTypeRef(t.Fun.Return)
		}
		return FuncType{Params: params, Return: ret}
	}
	switch *t.Simple {
	case "int":
		return IntType{}
	case "float":
		return FloatType{}
	case "string":
		return StringType{}
	case "bool":
		return BoolType{}
	default:
		return AnyType{}
	}
}

func checkExpr(e *parser.Expr, env *Env) (Type, error) {
	return checkExprWithExpected(e, env, nil)
}

func checkExprWithExpected(e *parser.Expr, env *Env, expected Type) (Type, error) {
	return checkEquality(e.Equality, env, expected)
}

func checkEquality(e *parser.Equality, env *Env, expected Type) (Type, error) {
	left, err := checkComparison(e.Left, env, nil)
	if err != nil {
		return nil, err
	}
	for _, op := range e.Right {
		right, err := checkComparison(op.Right, env, nil)
		if err != nil {
			return nil, err
		}
		if !left.Equal(right) {
			return nil, errIncompatibleEquality(op.Pos)
		}
		left = BoolType{}
	}
	return left, nil
}

func checkComparison(c *parser.Comparison, env *Env, expected Type) (Type, error) {
	left, err := checkTerm(c.Left, env, nil)
	if err != nil {
		return nil, err
	}
	for _, op := range c.Right {
		right, err := checkTerm(op.Right, env, nil)
		if err != nil {
			return nil, err
		}
		if !left.Equal(right) {
			return nil, errIncompatibleComparison(op.Pos)
		}
		left = BoolType{}
	}
	return left, nil
}

func checkTerm(t *parser.Term, env *Env, expected Type) (Type, error) {
	left, err := checkFactor(t.Left, env, nil)
	if err != nil {
		return nil, err
	}
	for _, op := range t.Right {
		right, err := checkFactor(op.Right, env, nil)
		if err != nil {
			return nil, err
		}
		if !left.Equal(right) {
			return nil, errTypeMismatch(op.Pos, left, right)
		}
	}
	return left, nil
}

func checkFactor(f *parser.Factor, env *Env, expected Type) (Type, error) {
	left, err := checkUnary(f.Left, env, nil)
	if err != nil {
		return nil, err
	}
	for _, op := range f.Right {
		right, err := checkUnary(op.Right, env, nil)
		if err != nil {
			return nil, err
		}
		if !left.Equal(right) {
			return nil, errTypeMismatch(op.Pos, left, right)
		}
	}
	return left, nil
}

func checkUnary(u *parser.Unary, env *Env, expected Type) (Type, error) {
	return checkPrimary(u.Value, env, expected)
}

func checkPrimary(p *parser.Primary, env *Env, expected Type) (Type, error) {
	switch {
	case p.Lit != nil:
		switch {
		case p.Lit.Int != nil:
			return IntType{}, nil
		case p.Lit.Float != nil:
			return FloatType{}, nil
		case p.Lit.Str != nil:
			return StringType{}, nil
		case p.Lit.Bool != nil:
			return BoolType{}, nil
		}

	case p.Selector != nil:
		typ, err := env.GetVar(p.Selector.Root)
		if err != nil {
			return nil, errUnknownVariable(p.Pos, p.Selector.Root)
		}
		// TODO: implement proper struct/stream field access checking
		return typ, nil

	case p.Call != nil:
		fnType, err := env.GetVar(p.Call.Func)
		if err != nil {
			return nil, errUnknownFunction(p.Pos, p.Call.Func)
		}

		switch ft := fnType.(type) {
		case FuncType:
			argCount := len(p.Call.Args)
			paramCount := len(ft.Params)

			if argCount > paramCount {
				return nil, errTooManyArgs(p.Pos, paramCount, argCount)
			}

			for i := 0; i < argCount; i++ {
				argType, err := checkExprWithExpected(p.Call.Args[i], env, ft.Params[i])
				if err != nil {
					return nil, err
				}
				if !argType.Equal(ft.Params[i]) {
					return nil, errArgTypeMismatch(p.Pos, i, ft.Params[i], argType)
				}
			}

			if argCount == paramCount {
				return ft.Return, nil
			}
			return curryFuncType(ft.Params[argCount:], ft.Return), nil

		case BuiltinFuncType:
			for _, arg := range p.Call.Args {
				if _, err := checkExpr(arg, env); err != nil {
					return nil, err
				}
			}
			return VoidType{}, nil

		default:
			return nil, errNotFunction(p.Pos, p.Call.Func)
		}

	case p.FunExpr != nil:
		return checkFunExpr(p.FunExpr, env, expected, p.Pos)

	case p.Group != nil:
		return checkExprWithExpected(p.Group, env, expected)
	}

	return nil, errInvalidPrimary(p.Pos)
}

func checkFunExpr(f *parser.FunExpr, env *Env, expected Type, pos lexer.Position) (Type, error) {
	var expectedFunc *FuncType
	if ft, ok := expected.(FuncType); ok {
		expectedFunc = &ft
	}

	paramTypes := make([]Type, len(f.Params))
	for i, p := range f.Params {
		if p.Type != nil {
			paramTypes[i] = resolveTypeRef(p.Type)
		} else if expectedFunc != nil && i < len(expectedFunc.Params) {
			paramTypes[i] = expectedFunc.Params[i]
		} else {
			paramTypes[i] = &TypeVar{Name: fmt.Sprintf("T_%s", p.Name)}
		}
	}

	var declaredRet Type
	if f.Return != nil {
		declaredRet = resolveTypeRef(f.Return)
	} else if expectedFunc != nil {
		declaredRet = expectedFunc.Return
	} else {
		declaredRet = &TypeVar{Name: "R"}
	}

	child := NewEnv(env)
	for i, p := range f.Params {
		child.SetVar(p.Name, paramTypes[i])
	}

	if f.ExprBody != nil {
		actualRet, err := checkExprWithExpected(f.ExprBody, child, declaredRet)
		if err != nil {
			return nil, err
		}
		declaredRet = actualRet
	} else {
		for _, stmt := range f.BlockBody {
			if err := checkStmt(stmt, child, declaredRet); err != nil {
				return nil, err
			}
		}
	}

	return FuncType{Params: paramTypes, Return: declaredRet}, nil
}

func curryFuncType(params []Type, ret Type) Type {
	if len(params) == 0 {
		return ret
	}
	return FuncType{
		Params: []Type{params[0]},
		Return: curryFuncType(params[1:], ret),
	}
}

```

## types/errors.go

```go
package types

import (
	"fmt"

	"github.com/alecthomas/participle/v2/lexer"
	"mochi/diagnostic"
)

// --- Type Checker Diagnostic Helpers (T000 - T099) ---

func errLetMissingTypeOrValue(pos lexer.Position) error {
	return diagnostic.New("T000", pos,
		"`let` requires a type annotation or a value",
		"Write `let x = ...` or `let x: int`.")
}

func errAssignUndeclared(pos lexer.Position, name string) error {
	return diagnostic.New("T001", pos,
		fmt.Sprintf("assignment to undeclared variable: %s", name),
		"Declare the variable using `let` first.")
}

func errUnknownVariable(pos lexer.Position, name string) error {
	return diagnostic.New("T002", pos,
		fmt.Sprintf("undefined variable: %s", name),
		"Check if the variable was declared in this scope.")
}

func errUnknownFunction(pos lexer.Position, name string) error {
	return diagnostic.New("T003", pos,
		fmt.Sprintf("unknown function: %s", name),
		"Ensure the function is defined before it's called.")
}

func errTypeMismatch(pos lexer.Position, expected, actual Type) error {
	return diagnostic.New("T004", pos,
		fmt.Sprintf("type mismatch: expected %s but got %s", expected, actual),
		"Change the value to match the expected type.")
}

func errCannotAssign(pos lexer.Position, rhs Type, lhsName string, lhs Type) error {
	return diagnostic.New("T005", pos,
		fmt.Sprintf("cannot assign %s to %s (expected %s)", rhs, lhsName, lhs),
		"Ensure the types on both sides of `=` are compatible.")
}

func errParamMissingType(pos lexer.Position, name string) error {
	return diagnostic.New("T006", pos,
		fmt.Sprintf("parameter `%s` is missing a type", name),
		"Add a type annotation like `x: int`.")
}

func errExpectBoolean(pos lexer.Position) error {
	return diagnostic.New("T007", pos,
		"`expect` must be a boolean expression",
		"Return a `true` or `false` condition inside `expect`.")
}

func errTooManyArgs(pos lexer.Position, expected, actual int) error {
	return diagnostic.New("T008", pos,
		fmt.Sprintf("too many arguments: expected %d, got %d", expected, actual),
		"Remove extra arguments or update the function definition.")
}

func errArgTypeMismatch(pos lexer.Position, index int, expected, actual Type) error {
	return diagnostic.New("T009", pos,
		fmt.Sprintf("argument %d type mismatch: expected %s, got %s", index+1, expected, actual),
		"Check the order and type of function arguments.")
}

func errNotFunction(pos lexer.Position, name string) error {
	return diagnostic.New("T010", pos,
		fmt.Sprintf("%s is not a function", name),
		"Use a function or closure in this position.")
}

func errIncompatibleEquality(pos lexer.Position) error {
	return diagnostic.New("T011", pos,
		"incompatible types in equality expression",
		"Ensure both sides of `==` or `!=` are the same type.")
}

func errIncompatibleComparison(pos lexer.Position) error {
	return diagnostic.New("T012", pos,
		"incompatible types in comparison expression",
		"Use comparable types like numbers or strings.")
}

func errInvalidPrimary(pos lexer.Position) error {
	return diagnostic.New("T013", pos,
		"invalid primary expression",
		"Check if the expression is valid or complete.")
}

func errReturnMismatch(pos lexer.Position, expected, actual Type) error {
	return diagnostic.New("T014", pos,
		fmt.Sprintf("return type mismatch: expected %s but got %s", expected, actual),
		"Ensure the returned value matches the declared function return type.")
}

```

## interpreter/interpreter.go

```go
package interpreter

import (
	"errors"
	"fmt"
	"github.com/alecthomas/participle/v2/lexer"
	"mochi/ast"
	"mochi/parser"
	"mochi/types"
	"strings"
)

// Interpreter executes Mochi programs using a shared runtime and type environment.
type Interpreter struct {
	prog  *parser.Program
	env   *types.Env
	types *types.Env
}

func New(prog *parser.Program, typesEnv *types.Env) *Interpreter {
	return &Interpreter{
		prog:  prog,
		env:   types.NewEnv(nil),
		types: typesEnv,
	}
}

func (i *Interpreter) Env() *types.Env { return i.env }

func (i *Interpreter) Run() error {
	var testFailures []error

	for _, stmt := range i.prog.Statements {
		if stmt.Test != nil {
			name := stmt.Test.Name
			fmt.Printf("🔍 Test %s\n", name)

			child := types.NewEnv(i.env)
			interp := &Interpreter{prog: i.prog, env: child, types: i.types}

			var failed error
			for _, s := range stmt.Test.Body {
				if err := interp.evalStmt(s); err != nil {
					failed = fmt.Errorf("❌ %s: %w", name, err)
					break // stop this test, but continue others
				}
			}

			if failed != nil {
				fmt.Println(failed)
				testFailures = append(testFailures, failed)
			} else {
				fmt.Printf("✅ %s passed\n", name)
			}

		} else {
			if err := i.evalStmt(stmt); err != nil {
				return err // still stop on non-test failure
			}
		}
	}

	if len(testFailures) > 0 {
		var sb strings.Builder
		fmt.Fprintf(&sb, "\n💥 %d test(s) failed:\n", len(testFailures))
		for _, err := range testFailures {
			fmt.Fprintf(&sb, "  - %v\n", err)
		}
		return errors.New(sb.String())
	}

	return nil
}

type closure struct {
	Fn         *parser.FunExpr
	Env        *types.Env
	Args       []any
	FullParams []*parser.Param
}

func (c closure) String() string {
	return fmt.Sprintf("<closure %d/%d args>", len(c.Args), len(c.Fn.Params)+len(c.Args))
}

// --- Statement Evaluation ---

func (i *Interpreter) evalStmt(s *parser.Statement) error {
	switch {
	case s.Let != nil:
		val := any(nil)
		var err error
		if s.Let.Value != nil {
			val, err = i.evalExpr(s.Let.Value)
			if err != nil {
				return err
			}
		}
		i.env.SetValue(s.Let.Name, val)
		return nil

	case s.Assign != nil:
		val, err := i.evalExpr(s.Assign.Value)
		if err != nil {
			return err
		}
		return i.env.UpdateValue(s.Assign.Name, val)

	case s.Expr != nil:
		_, err := i.evalExpr(s.Expr.Expr)
		return err

	case s.Fun != nil:
		i.env.SetFunc(s.Fun.Name, s.Fun)
		return nil

	case s.Return != nil:
		val, err := i.evalExpr(s.Return.Value)
		if err != nil {
			return err
		}
		return returnSignal{val}

	case s.If != nil:
		return i.evalIf(s.If)

	case s.For != nil:
		return i.evalFor(s.For)

	case s.Test != nil:
		fmt.Printf("🔍 Test %s\n", s.Test.Name)
		child := types.NewEnv(i.env)
		interp := &Interpreter{prog: i.prog, env: child, types: i.types}
		for _, stmt := range s.Test.Body {
			if err := interp.evalStmt(stmt); err != nil {
				return fmt.Errorf("❌ %s: %w", s.Test.Name, err)
			}
		}
		fmt.Printf("✅ %s passed\n", s.Test.Name)
		return nil

	case s.Expect != nil:
		val, err := i.evalExpr(s.Expect.Value)
		if err != nil {
			return err
		}
		if b, ok := val.(bool); !ok || !b {
			return fmt.Errorf("expect failed: %s", ast.PrettyStatement(s))
		}
		return nil

	default:
		return fmt.Errorf("unsupported statement: %s", ast.PrettyStatement(s))
	}
}

func (i *Interpreter) evalIf(stmt *parser.IfStmt) error {
	condVal, err := i.evalExpr(stmt.Cond)
	if err != nil {
		return err
	}
	if truthy(condVal) {
		for _, s := range stmt.Then {
			if err := i.evalStmt(s); err != nil {
				return err
			}
		}
		return nil
	}
	if stmt.ElseIf != nil {
		return i.evalIf(stmt.ElseIf)
	}
	for _, s := range stmt.Else {
		if err := i.evalStmt(s); err != nil {
			return err
		}
	}
	return nil
}

func (i *Interpreter) evalFor(stmt *parser.ForStmt) error {
	fromVal, err := i.evalExpr(stmt.Start)
	if err != nil {
		return err
	}
	toVal, err := i.evalExpr(stmt.End)
	if err != nil {
		return err
	}
	fromInt, ok1 := fromVal.(int)
	toInt, ok2 := toVal.(int)
	if !ok1 || !ok2 {
		return errInvalidRangeBounds(stmt.Pos, fmt.Sprintf("%T", fromVal), fmt.Sprintf("%T", toVal))
	}
	for x := fromInt; x < toInt; x++ {
		i.env.SetValue(stmt.Name, x)
		for _, s := range stmt.Body {
			if err := i.evalStmt(s); err != nil {
				return err
			}
		}
	}
	return nil
}

// --- Expression Evaluation ---

func (i *Interpreter) evalExpr(e *parser.Expr) (any, error) {
	if e == nil {
		return nil, errors.New("nil expression")
	}
	return i.evalEquality(e.Equality)
}

func (i *Interpreter) evalEquality(e *parser.Equality) (any, error) {
	left, err := i.evalComparison(e.Left)
	if err != nil {
		return nil, err
	}
	for _, op := range e.Right {
		right, err := i.evalComparison(op.Right)
		if err != nil {
			return nil, err
		}
		left, err = applyBinary(op.Pos, left, op.Op, right)
		if err != nil {
			return nil, err
		}
	}
	return left, nil
}

func (i *Interpreter) evalComparison(c *parser.Comparison) (any, error) {
	left, err := i.evalTerm(c.Left)
	if err != nil {
		return nil, err
	}
	for _, op := range c.Right {
		right, err := i.evalTerm(op.Right)
		if err != nil {
			return nil, err
		}
		left, err = applyBinary(op.Pos, left, op.Op, right)
		if err != nil {
			return nil, err
		}
	}
	return left, nil
}

func (i *Interpreter) evalTerm(t *parser.Term) (any, error) {
	left, err := i.evalFactor(t.Left)
	if err != nil {
		return nil, err
	}
	for _, op := range t.Right {
		right, err := i.evalFactor(op.Right)
		if err != nil {
			return nil, err
		}
		left, err = applyBinary(op.Pos, left, op.Op, right)
		if err != nil {
			return nil, err
		}
	}
	return left, nil
}

func (i *Interpreter) evalFactor(f *parser.Factor) (any, error) {
	left, err := i.evalUnary(f.Left)
	if err != nil {
		return nil, err
	}
	for _, op := range f.Right {
		right, err := i.evalUnary(op.Right)
		if err != nil {
			return nil, err
		}
		left, err = applyBinary(op.Pos, left, op.Op, right)
		if err != nil {
			return nil, err
		}
	}
	return left, nil
}

func (i *Interpreter) evalUnary(u *parser.Unary) (any, error) {
	val, err := i.evalPrimary(u.Value)
	if err != nil {
		return nil, err
	}
	for j := len(u.Ops) - 1; j >= 0; j-- {
		val, err = applyUnary(u.Pos, u.Ops[j], val)
		if err != nil {
			return nil, err
		}
	}
	return val, nil
}

func (i *Interpreter) evalPrimary(p *parser.Primary) (any, error) {
	switch {
	case p.Lit != nil:
		return i.evalLiteral(p.Lit)

	case p.Call != nil:
		return i.evalCall(p.Call)

	case p.Group != nil:
		return i.evalExpr(p.Group)

	case p.FunExpr != nil:
		return closure{Fn: p.FunExpr, Env: i.env.Copy(), FullParams: p.FunExpr.Params}, nil

	case p.Selector != nil:
		val, err := i.env.GetValue(p.Selector.Root)
		if err != nil {
			return nil, errUndefinedVariable(p.Pos, p.Selector.Root)
		}
		for _, field := range p.Selector.Tail {
			obj, ok := val.(map[string]any)
			if !ok {
				return nil, errFieldAccessOnNonObject(p.Pos, field, fmt.Sprintf("%T", val))
			}
			val = obj[field]
		}
		return val, nil

	default:
		return nil, errInvalidPrimaryExpression(p.Pos)
	}
}

/*
func (i *Interpreter) evalLiteral(l *parser.Literal) (any, error) {
	switch {
	case l.Int != nil:
		var n int
		if _, err := fmt.Sscanf(*l.Int, "%d", &n); err != nil {
			return nil, errInvalidIntLiteral(l.Pos, *l.Int)
		}
		return n, nil

	case l.Float != nil:
		var f float64
		if _, err := fmt.Sscanf(*l.Float, "%f", &f); err != nil {
			return nil, errInvalidFloatLiteral(l.Pos, *l.Float)
		}
		return f, nil

	case l.Str != nil:
		return *l.Str, nil

	case l.Bool != nil:
		switch *l.Bool {
		case "true":
			return true, nil
		case "false":
			return false, nil
		default:
			return nil, errInvalidBoolLiteral(l.Pos, *l.Bool)
		}

	default:
		return nil, errInvalidLiteral(l.Pos)
	}
}
*/

func (i *Interpreter) evalLiteral(l *parser.Literal) (any, error) {
	switch {
	case l.Int != nil:
		return *l.Int, nil
	case l.Float != nil:
		return *l.Float, nil
	case l.Str != nil:
		return *l.Str, nil
	case l.Bool != nil:
		return *l.Bool, nil
	default:
		return nil, errInvalidLiteral(l.Pos)
	}
}

func (i *Interpreter) evalCall(c *parser.CallExpr) (any, error) {
	if c.Func == "print" {
		var sb strings.Builder
		for _, arg := range c.Args {
			val, err := i.evalExpr(arg)
			if err != nil {
				return nil, err
			}
			fmt.Fprintf(&sb, "%v ", val)
		}
		_, err := fmt.Fprintln(i.env.Writer(), strings.TrimSpace(sb.String()))
		return nil, err
	}

	if fn, ok := i.env.GetFunc(c.Func); ok {
		argCount := len(c.Args)
		paramCount := len(fn.Params)

		if argCount > paramCount {
			return nil, errTooManyFunctionArgs(c.Pos, c.Func, paramCount, argCount)
		}

		if argCount < paramCount {
			applied := make([]any, argCount)
			for idx := range c.Args {
				val, err := i.evalExpr(c.Args[idx])
				if err != nil {
					return nil, err
				}
				applied[idx] = val
			}
			remainingParams := fn.Params[argCount:]
			return closure{
				Fn: &parser.FunExpr{
					Params:    remainingParams,
					BlockBody: fn.Body,
				},
				Env:        i.env.Copy(),
				Args:       applied,
				FullParams: fn.Params,
			}, nil
		}

		child := types.NewEnv(i.env)
		for idx, param := range fn.Params {
			val, err := i.evalExpr(c.Args[idx])
			if err != nil {
				return nil, err
			}
			child.SetValue(param.Name, val)
		}
		old := i.env
		i.env = child
		defer func() { i.env = old }()
		for _, stmt := range fn.Body {
			if err := i.evalStmt(stmt); err != nil {
				if r, ok := err.(returnSignal); ok {
					return r.value, nil
				}
				return nil, err
			}
		}
		return nil, nil
	}

	val, err := i.env.GetValue(c.Func)
	if err == nil {
		if cl, ok := val.(closure); ok {
			totalArgs := len(cl.Args) + len(c.Args)
			fullParamCount := len(cl.FullParams)

			if totalArgs > fullParamCount {
				return nil, errTooManyFunctionArgs(c.Pos, c.Func, fullParamCount, totalArgs)
			}

			allArgs := append([]any{}, cl.Args...)
			for _, arg := range c.Args {
				val, err := i.evalExpr(arg)
				if err != nil {
					return nil, err
				}
				allArgs = append(allArgs, val)
			}

			if totalArgs < fullParamCount {
				return closure{
					Fn: &parser.FunExpr{
						Params:    cl.Fn.Params[totalArgs-len(cl.Args):],
						BlockBody: cl.Fn.BlockBody,
						ExprBody:  cl.Fn.ExprBody,
					},
					Env:        cl.Env,
					Args:       allArgs,
					FullParams: cl.FullParams,
				}, nil
			}

			if len(cl.FullParams) != len(allArgs) {
				return nil, errInternalClosureArgMismatch(c.Pos)
			}

			child := types.NewEnv(cl.Env)
			for idx, param := range cl.FullParams {
				child.SetValue(param.Name, allArgs[idx])
			}

			old := i.env
			i.env = child
			defer func() { i.env = old }()
			if cl.Fn.ExprBody != nil {
				return i.evalExpr(cl.Fn.ExprBody)
			}
			for _, stmt := range cl.Fn.BlockBody {
				if err := i.evalStmt(stmt); err != nil {
					if r, ok := err.(returnSignal); ok {
						return r.value, nil
					}
					return nil, err
				}
			}
			return nil, nil
		}
	}

	return nil, errUndefinedFunctionOrClosure(c.Pos, c.Func)
}

// --- Return ---

type returnSignal struct{ value any }

func (r returnSignal) Error() string { return "return" }

func applyBinary(pos lexer.Position, left any, op string, right any) (any, error) {
	switch l := left.(type) {
	case bool:
		if r, ok := right.(bool); ok {
			switch op {
			case "==":
				return l == r, nil
			case "!=":
				return l != r, nil
			}
		}
	case int:
		if r, ok := right.(int); ok {
			return applyIntBinary(pos, l, op, r)
		}
	case float64:
		if r, ok := right.(float64); ok {
			return applyFloatBinary(pos, l, op, r)
		}
	case string:
		if r, ok := right.(string); ok {
			switch op {
			case "+":
				return l + r, nil
			case "==":
				return l == r, nil
			case "!=":
				return l != r, nil
			}
		}
	}
	return nil, errInvalidOperator(pos, op, fmt.Sprintf("%T", left), fmt.Sprintf("%T", right))
}

func applyIntBinary(pos lexer.Position, l int, op string, r int) (any, error) {
	switch op {
	case "/":
		if r == 0 {
			return nil, errDivisionByZero(pos)
		}
		return l / r, nil
	case "+":
		return l + r, nil
	case "-":
		return l - r, nil
	case "*":
		return l * r, nil
	case "==":
		return l == r, nil
	case "!=":
		return l != r, nil
	case "<":
		return l < r, nil
	case "<=":
		return l <= r, nil
	case ">":
		return l > r, nil
	case ">=":
		return l >= r, nil
	default:
		return nil, errInvalidOperator(pos, op, "int", "int")
	}
}

func applyFloatBinary(pos lexer.Position, l float64, op string, r float64) (any, error) {
	switch op {
	case "/":
		if r == 0 {
			return nil, errDivisionByZero(pos)
		}
		return l / r, nil
	case "+":
		return l + r, nil
	case "-":
		return l - r, nil
	case "*":
		return l * r, nil
	case "==":
		return l == r, nil
	case "!=":
		return l != r, nil
	case "<":
		return l < r, nil
	case "<=":
		return l <= r, nil
	case ">":
		return l > r, nil
	case ">=":
		return l >= r, nil
	default:
		return nil, errInvalidOperator(pos, op, "float", "float")
	}
}

func applyUnary(pos lexer.Position, op string, val any) (any, error) {
	switch op {
	case "-":
		switch v := val.(type) {
		case int:
			return -v, nil
		case float64:
			return -v, nil
		default:
			return nil, errInvalidUnaryOperator(pos, op, fmt.Sprintf("%T", val))
		}
	case "!":
		if b, ok := val.(bool); ok {
			return !b, nil
		}
		return nil, errInvalidUnaryOperator(pos, op, fmt.Sprintf("%T", val))
	default:
		return nil, errUnknownUnaryOperator(pos, op)
	}
}

func truthy(val any) bool {
	switch v := val.(type) {
	case bool:
		return v
	case int:
		return v != 0
	case float64:
		return v != 0
	case string:
		return v != ""
	default:
		return val != nil
	}
}

```

## interpreter/errors.go

```go
package interpreter

import (
	"fmt"

	"github.com/alecthomas/participle/v2/lexer"
	"mochi/diagnostic"
)

// --- Runtime Diagnostics (I000 - I099) ---

func errUndefinedVariable(pos lexer.Position, name string) error {
	return diagnostic.New("I000", pos,
		fmt.Sprintf("undefined variable: %s", name),
		"Make sure the variable is declared before use.")
}

func errFieldAccessOnNonObject(pos lexer.Position, field string, typ string) error {
	return diagnostic.New("I001", pos,
		fmt.Sprintf("cannot access field '%s' on non-object of type %s", field, typ),
		"Use a map-like object to access fields.")
}

func errInvalidPrimaryExpression(pos lexer.Position) error {
	return diagnostic.New("I002", pos,
		"invalid primary expression",
		"Expected a literal, function, or variable.")
}

func errInvalidLiteral(pos lexer.Position) error {
	return diagnostic.New("I003", pos,
		"invalid literal value",
		"Check the syntax of the literal.")
}

func errUndefinedFunctionOrClosure(pos lexer.Position, name string) error {
	return diagnostic.New("I004", pos,
		fmt.Sprintf("undefined function or closure: %s", name),
		"Ensure the function or closure exists in scope.")
}

func errTooManyFunctionArgs(pos lexer.Position, name string, expected, actual int) error {
	return diagnostic.New("I005", pos,
		fmt.Sprintf("function %s expects %d arguments, got %d", name, expected, actual),
		"Pass the correct number of arguments.")
}

func errInternalClosureArgMismatch(pos lexer.Position) error {
	return diagnostic.New("I006", pos,
		"internal error: argument count mismatch in closure",
		"Check closure invocation logic.")
}

func errInvalidOperator(pos lexer.Position, op string, left, right string) error {
	return diagnostic.New("I007", pos,
		fmt.Sprintf("cannot apply operator '%s' to types %s and %s", op, left, right),
		"Use compatible types for this operator.")
}

func errInvalidUnaryOperator(pos lexer.Position, op string, typ string) error {
	return diagnostic.New("I008", pos,
		fmt.Sprintf("invalid use of unary '%s' on %s", op, typ),
		"Use unary operators only with numeric or boolean values.")
}

func errUnknownUnaryOperator(pos lexer.Position, op string) error {
	return diagnostic.New("I009", pos,
		fmt.Sprintf("unknown unary operator: %s", op),
		"Supported operators are '-', '!'")
}

func errInvalidRangeBounds(pos lexer.Position, fromType, toType string) error {
	return diagnostic.New("I010", pos,
		fmt.Sprintf("range bounds must be integers, got %s and %s", fromType, toType),
		"Ensure both `for x in a..b` bounds are integers.")
}

func errDivisionByZero(pos lexer.Position) error {
	return diagnostic.New("I011", pos,
		"division by zero",
		"Make sure the denominator is not zero.")
}

```

## golden/golden.go

```go
package golden

import (
	"bytes"
	"flag"
	"os"
	"path/filepath"
	"strings"
	"testing"
)

// update is a flag to overwrite golden files with new output.
var update = flag.Bool("update", false, "update golden files")

// Runner defines a test processor function.
type Runner func(srcPath string) ([]byte, error)

// Run executes golden file-based tests.
// It compares processed output of `*.srcExt` files with corresponding `*.goldenExt` files.
func Run(t *testing.T, dir, srcExt, goldenExt string, fn Runner) {
	rootDir := findRepoRoot(t)
	pattern := filepath.Join(rootDir, dir, "*"+srcExt)

	files, err := filepath.Glob(pattern)
	if err != nil {
		t.Fatalf("failed to list %s files in %s: %v", srcExt, dir, err)
	}
	if len(files) == 0 {
		t.Fatalf("no test files found: %s", pattern)
	}

	for _, src := range files {
		name := strings.TrimSuffix(filepath.Base(src), srcExt)
		wantPath := filepath.Join(rootDir, dir, name+goldenExt)

		t.Run(name, func(t *testing.T) {
			got, err := fn(src)
			if err != nil {
				t.Fatalf("process error: %v", err)
			}
			if got == nil {
				t.Fatal("got nil output")
			}
			got = normalizeOutput(rootDir, got)

			if *update {
				if err := os.WriteFile(wantPath, got, 0644); err != nil {
					t.Fatalf("failed to write golden: %v", err)
				}
				t.Logf("updated: %s", wantPath)
				return
			}

			want, err := os.ReadFile(wantPath)
			if err != nil {
				t.Fatalf("failed to read golden: %v", err)
			}
			want = bytes.TrimSpace(want)

			if !bytes.Equal(got, want) {
				t.Errorf("golden mismatch for %s\n\n--- Got ---\n%s\n\n--- Want ---\n%s\n", name+goldenExt, got, want)
			}
		})
	}
}

// findRepoRoot walks up the directory tree to locate the `go.mod` file.
func findRepoRoot(t *testing.T) string {
	dir, err := os.Getwd()
	if err != nil {
		t.Fatal("cannot determine working directory")
	}
	for i := 0; i < 10; i++ {
		if _, err := os.Stat(filepath.Join(dir, "go.mod")); err == nil {
			return dir
		}
		parent := filepath.Dir(dir)
		if parent == dir {
			break
		}
		dir = parent
	}
	t.Fatal("go.mod not found (not in Go module)")
	return ""
}

// normalizeOutput strips project-specific paths and whitespace for clean diffing.
func normalizeOutput(root string, b []byte) []byte {
	out := string(b)
	out = strings.ReplaceAll(out, filepath.ToSlash(root)+"/", "")
	out = strings.ReplaceAll(out, filepath.ToSlash(root), "")
	out = strings.ReplaceAll(out, "github.com/mochi-lang/mochi/", "")
	out = strings.ReplaceAll(out, "mochi/tests/", "tests/")
	return []byte(strings.TrimSpace(out))
}

```


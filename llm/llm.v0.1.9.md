// generated by mochi-run, do not edit

# Mochi Source Files for LLM Ingestion

> Version: `0.1.9`

This document includes all core source files used by the Mochi interpreter and runtime toolchain.

## üìñ Overview

- **cmd/mochi/main.go**: Entry point of the Mochi CLI tool. Orchestrates example compilation, AST generation, and LLM-ready documentation output.
- **parser/parser.go**: Defines the Mochi parser using a top-down recursive descent approach. Transforms source code into an abstract syntax tree (AST).
- **ast/ast.go**: Contains data structures representing Mochi's typed abstract syntax tree (AST), including programs, expressions, and types.
- **ast/convert.go**: Converts parser output into typed AST used by later stages (e.g. interpreter, type checker).
- **ast/pretty.go**: Implements utilities to format and pretty-print AST nodes into human-readable forms (e.g. Lisp-style).
- **interpreter/env.go**: Implements the runtime environment (variable bindings, output writer, scopes).
- **interpreter/interpreter.go**: Implements the Mochi interpreter which executes AST nodes in a given environment.

---

## cmd/mochi/main.go

```go
package main

import (
	"flag"
	"fmt"
	"os"

	"mochi/ast"
	"mochi/interpreter"
	"mochi/parser"
)

var (
	version = "dev" // set via -ldflags
	showAST = flag.Bool("ast", false, "Print the parsed AST in Lisp format")
	run     = flag.Bool("run", false, "Interpret and execute the program")
)

func main() {
	flag.Usage = func() {
		fmt.Fprintf(flag.CommandLine.Output(), `Mochi Language (v%s)

Usage:
  mochi [options] <file.mochi>

Options:
`, version)
		flag.PrintDefaults()
	}

	flag.Parse()

	if flag.NArg() != 1 {
		flag.Usage()
		os.Exit(1)
	}

	filename := flag.Arg(0)

	source, err := os.ReadFile(filename)
	if err != nil {
		fmt.Fprintf(os.Stderr, "‚ùå Failed to read %s: %v\n", filename, err)
		os.Exit(1)
	}

	prog, err := parser.Parser.ParseString(filename, string(source))
	if err != nil {
		fmt.Fprintf(os.Stderr, "‚ùå Parse error in %s: %v\n", filename, err)
		os.Exit(1)
	}

	fmt.Printf("‚úÖ Parsed %s (Mochi v%s)\n", filename, version)

	if *showAST {
		fmt.Println("\n--- AST ---")
		tree := ast.FromProgram(prog)
		fmt.Println(tree.String())
	}

	if *run {
		fmt.Println("\n--- Running ---")
		interp := interpreter.New(prog)
		if err := interp.Run(); err != nil {
			fmt.Fprintf(os.Stderr, "‚ùå Runtime error: %v\n", err)
			os.Exit(1)
		}
	}
}

```

## parser/parser.go

```go
package parser

import (
	"github.com/alecthomas/participle/v2"
	"github.com/alecthomas/participle/v2/lexer"
)

// --- Mochi Lexer ---
var mochiLexer = lexer.MustSimple([]lexer.SimpleRule{
	{Name: "Comment", Pattern: `//[^\n]*`},
	{Name: "Bool", Pattern: `\b(true|false)\b`},
	{Name: "Ident", Pattern: `[a-zA-Z_][a-zA-Z0-9_]*`},
	{Name: "Float", Pattern: `\d+\.\d+`},
	{Name: "Int", Pattern: `\d+`},
	{Name: "String", Pattern: `"(?:\\.|[^"])*"`},
	{Name: "Punct", Pattern: `==|!=|<=|>=|=>|\.\.|[-+*/=<>!{}(),.:]`},
	{Name: "Whitespace", Pattern: `[ \t\n\r]+`},
})

// --- Program Structure ---

type Program struct {
	Pos        lexer.Position
	Statements []*Statement `@@*`
}

type Statement struct {
	Test   *TestBlock  `  @@`
	Expect *ExpectStmt `| @@`
	Agent  *AgentDecl  `| @@`
	Stream *StreamDecl `| @@`
	On     *OnHandler  `| @@`
	Let    *LetStmt    `| @@`
	Assign *AssignStmt `| @@`
	Fun    *FunStmt    `| @@`
	Return *ReturnStmt `| @@`
	If     *IfStmt     `| @@`
	For    *ForStmt    `| @@`
	Expr   *ExprStmt   `| @@`
}

// --- Test and Expect ---

type TestBlock struct {
	Pos  lexer.Position
	Test string       `"test"`
	Name string       `@String`
	Body []*Statement `"{" @@* "}"`
}

type ExpectStmt struct {
	Pos    lexer.Position
	Expect string `"expect"`
	Value  *Expr  `@@`
}

// --- If Statement ---

type IfStmt struct {
	Pos    lexer.Position
	If     string       `"if"`
	Cond   *Expr        `@@`
	Then   []*Statement `"{" @@* "}"`
	ElseIf *IfStmt      `[ "else" @@`
	Else   []*Statement `| "else" "{" @@* "}" ]`
}

// --- For Statement ---

type ForStmt struct {
	Pos   lexer.Position
	For   string       `"for"`
	Name  string       `@Ident`
	In    string       `"in"`
	Start *Expr        `@@`
	Dots  string       `".."` // required token
	End   *Expr        `@@`
	Body  []*Statement `"{" @@* "}"`
}

// --- Type System ---

type TypeRef struct {
	Fun    *FunType `  @@`
	Simple *string  `| @Ident`
}

type FunType struct {
	Fun    string     `"fun"`
	Params []*TypeRef `"(" [ @@ { "," @@ } ] ")"`
	Return *TypeRef   `[ ":" @@ ]`
}

// --- Declarations & Statements ---

type LetStmt struct {
	Pos   lexer.Position
	Let   string   `"let"`
	Name  string   `@Ident`
	Type  *TypeRef `[ ":" @@ ]`
	Value *Expr    `[ "=" @@ ]`
}

type AssignStmt struct {
	Pos   lexer.Position
	Name  string `@Ident`
	Eq    string `"="`
	Value *Expr  `@@`
}

type FunStmt struct {
	Pos    lexer.Position
	Fun    string       `"fun"`
	Name   string       `@Ident`
	Params []*Param     `"(" [ @@ { "," @@ } ] ")"`
	Return *TypeRef     `[ ":" @@ ]`
	Body   []*Statement `"{" @@* "}"`
}

type ReturnStmt struct {
	Pos   lexer.Position
	Ret   string `"return"`
	Value *Expr  `@@`
}

type Param struct {
	Name string   `@Ident`
	Type *TypeRef `[ ":" @@ ]`
}

type ExprStmt struct {
	Pos  lexer.Position
	Expr *Expr `@@`
}

// --- Expressions ---

type Expr struct {
	Pos      lexer.Position
	Equality *Equality `@@`
}

type Equality struct {
	Left  *Comparison `@@`
	Right []*EqualOp  `@@*`
}

type EqualOp struct {
	Op    string      `@("==" | "!=")`
	Right *Comparison `@@`
}

type Comparison struct {
	Left  *Term     `@@`
	Right []*CompOp `@@*`
}

type CompOp struct {
	Op    string `@("<" | "<=" | ">" | ">=")`
	Right *Term  `@@`
}

type Term struct {
	Left  *Factor   `@@`
	Right []*TermOp `@@*`
}

type TermOp struct {
	Op    string  `@("+" | "-")`
	Right *Factor `@@`
}

type Factor struct {
	Left  *Unary      `@@`
	Right []*FactorOp `@@*`
}

type FactorOp struct {
	Op    string `@("*" | "/")`
	Right *Unary `@@`
}

type Unary struct {
	Ops   []string `{@("-" | "!")}`
	Value *Primary `@@`
}

type Primary struct {
	FunExpr  *FunExpr      `  @@`
	Call     *CallExpr     `| @@`
	Selector *SelectorExpr `| @@`
	Lit      *Literal      `| @@`
	Group    *Expr         `| "(" @@ ")"`
}

type FunExpr struct {
	Pos    lexer.Position
	Fun    string   `"fun"`
	Params []*Param `"(" [ @@ { "," @@ } ] ")"`
	Return *TypeRef `[ ":" @@ ]`
	Arrow  string   `"=>"`

	ExprBody  *Expr        `  @@`
	BlockBody []*Statement `| "{" @@* "}"`
}

// --- Atoms ---

type SelectorExpr struct {
	Root string   `@Ident`
	Tail []string `{ "." @Ident }`
}

type CallExpr struct {
	Pos    lexer.Position
	Func   string  `@Ident "("`
	Args   []*Expr `[ @@ { "," @@ } ]`
	RParen string  `")"`
}

type Literal struct {
	Pos   lexer.Position
	Float *string `  @Float`
	Int   *string `| @Int`
	Str   *string `| @String`
	Bool  *string `| @Bool`
}

// --- Stream / Struct Declarations ---

type StreamDecl struct {
	Pos    lexer.Position
	Stream string         `"stream"`
	Name   string         `@Ident`
	Fields []*StreamField `"{" @@* "}"`
}

type StreamField struct {
	Nested *StreamNestedField `  @@`
	Simple *StreamSimpleField `| @@`
}

type StreamSimpleField struct {
	Name string `@Ident`
	Type string `":" @Ident`
}

type StreamNestedField struct {
	Name string     `@Ident`
	Type string     `":"`
	Body *StructDef `@@`
}

type StructDef struct {
	LBrace string         `"{"`
	Fields []*StreamField `@@*`
	RBrace string         `"}"`
}

// --- On Handler ---

type OnHandler struct {
	Pos    lexer.Position
	On     string       `"on"`
	Stream string       `@Ident`
	As     string       `"as"`
	Alias  string       `@Ident`
	Body   []*Statement `"{" @@* "}"`
}

// --- Agent DSL ---

type AgentDecl struct {
	Pos   lexer.Position
	Agent string        `"agent"`
	Name  string        `@Ident`
	Body  []*AgentBlock `"{" @@* "}"`
}

type AgentBlock struct {
	Let    *LetStmt    `  @@`
	Assign *AssignStmt `| @@`
	On     *OnHandler  `| @@`
	Intent *IntentDecl `| @@`
}

type IntentDecl struct {
	Pos    lexer.Position
	Intent string       `"intent"`
	Name   string       `@Ident`
	Params []*Param     `"(" [ @@ { "," @@ } ] ")"`
	Return *TypeRef     `[ ":" @@ ]`
	Body   []*Statement `"{" @@* "}"`
}

// --- Parser ---

var Parser = participle.MustBuild[Program](
	participle.Lexer(mochiLexer),
	participle.Elide("Whitespace", "Comment"),
	participle.Unquote("String"),
	participle.UseLookahead(999),
)

```

## ast/ast.go

```go
package ast

import (
	"fmt"
	"regexp"
	"strings"
)

// Node is a simplified, uniform AST representation (inspired by Lisp)
type Node struct {
	Kind     string
	Value    any
	Children []*Node
}

// Print writes a compact Lisp-like tree to stdout
func (n *Node) Print(indent string) {
	fmt.Print(n.String())
}

// String returns the pretty-printed AST as a compact Lisp-like string
func (n *Node) String() string {
	var b strings.Builder
	write(&b, n, "")
	b.WriteString("\n")
	return b.String()
}

// write is a helper to recursively pretty-print the AST
func write(b *strings.Builder, n *Node, indent string) {
	b.WriteString(indent + "(" + n.Kind)
	if n.Value != nil {
		b.WriteString(" " + formatValue(n.Value))
	}

	if len(n.Children) == 0 {
		b.WriteString(")")
		return
	}

	// Check if all children are leaf nodes
	allLeaf := true
	for _, c := range n.Children {
		if len(c.Children) > 0 {
			allLeaf = false
			break
		}
	}

	if allLeaf {
		for _, c := range n.Children {
			b.WriteString(" (" + c.Kind)
			if c.Value != nil {
				b.WriteString(" " + formatValue(c.Value))
			}
			b.WriteString(")")
		}
		b.WriteString(")")
	} else {
		b.WriteString("\n")
		for _, c := range n.Children {
			write(b, c, indent+"  ")
			b.WriteString("\n")
		}
		b.WriteString(indent + ")")
	}
}

var safeIdent = regexp.MustCompile(`^[a-zA-Z0-9._-]+$`)

// formatValue returns a string representation of a value, quoting strings only when needed.
func formatValue(v any) string {
	switch s := v.(type) {
	case string:
		if safeIdent.MatchString(s) {
			return s
		}
		return fmt.Sprintf("%q", s)
	default:
		return fmt.Sprintf("%v", v)
	}
}

```

## ast/convert.go

```go
package ast

import "mochi/parser"

// FromProgram converts a parsed Program into an AST Node tree.
func FromProgram(p *parser.Program) *Node {
	root := &Node{Kind: "program"}
	for _, stmt := range p.Statements {
		root.Children = append(root.Children, FromStatement(stmt))
	}
	return root
}

// FromStatement converts a top-level Statement into a Node.
func FromStatement(s *parser.Statement) *Node {
	switch {
	case s.Let != nil:
		n := &Node{
			Kind:  "let",
			Value: s.Let.Name,
		}
		if s.Let.Type != nil {
			n.Children = append(n.Children, FromTypeRef(s.Let.Type))
		}
		if s.Let.Value != nil {
			n.Children = append(n.Children, FromExpr(s.Let.Value))
		}
		return n

	case s.Assign != nil:
		return &Node{
			Kind:  "assign",
			Value: s.Assign.Name,
			Children: []*Node{
				FromExpr(s.Assign.Value),
			},
		}

	case s.Fun != nil:
		n := &Node{Kind: "fun", Value: s.Fun.Name}
		for _, param := range s.Fun.Params {
			paramNode := &Node{Kind: "param", Value: param.Name}
			if param.Type != nil {
				paramNode.Children = append(paramNode.Children, FromTypeRef(param.Type))
			}
			n.Children = append(n.Children, paramNode)
		}
		if s.Fun.Return != nil {
			n.Children = append(n.Children, FromTypeRef(s.Fun.Return))
		}
		for _, stmt := range s.Fun.Body {
			n.Children = append(n.Children, FromStatement(stmt))
		}
		return n

	case s.Return != nil:
		return &Node{Kind: "return", Children: []*Node{FromExpr(s.Return.Value)}}

	case s.Expr != nil:
		return &Node{Kind: "exprstmt", Children: []*Node{FromExpr(s.Expr.Expr)}}

	case s.If != nil:
		return fromIfStmt(s.If)

	case s.For != nil:
		return fromForStmt(s.For)

	case s.Agent != nil:
		n := &Node{Kind: "agent", Value: s.Agent.Name}
		for _, block := range s.Agent.Body {
			switch {
			case block.Let != nil:
				n.Children = append(n.Children, FromStatement(&parser.Statement{Let: block.Let}))
			case block.Assign != nil:
				n.Children = append(n.Children, FromStatement(&parser.Statement{Assign: block.Assign}))
			case block.On != nil:
				n.Children = append(n.Children, fromOnHandler(block.On))
			case block.Intent != nil:
				n.Children = append(n.Children, fromIntent(block.Intent))
			}
		}
		return n

	case s.On != nil:
		return fromOnHandler(s.On)

	case s.Stream != nil:
		n := &Node{Kind: "stream", Value: s.Stream.Name}
		for _, field := range s.Stream.Fields {
			n.Children = append(n.Children, fromStreamField(field))
		}
		return n

	case s.Test != nil:
		n := &Node{Kind: "test", Value: s.Test.Name}
		for _, stmt := range s.Test.Body {
			n.Children = append(n.Children, FromStatement(stmt))
		}
		return n

	case s.Expect != nil:
		return &Node{Kind: "expect", Children: []*Node{FromExpr(s.Expect.Value)}}

	default:
		return &Node{Kind: "unknown"}
	}
}

func fromIfStmt(stmt *parser.IfStmt) *Node {
	n := &Node{Kind: "if"}
	n.Children = append(n.Children, FromExpr(stmt.Cond))
	thenBlock := &Node{Kind: "block"}
	for _, stmt := range stmt.Then {
		thenBlock.Children = append(thenBlock.Children, FromStatement(stmt))
	}
	n.Children = append(n.Children, thenBlock)

	if stmt.ElseIf != nil {
		n.Children = append(n.Children, fromIfStmt(stmt.ElseIf))
	} else if stmt.Else != nil {
		elseBlock := &Node{Kind: "block"}
		for _, stmt := range stmt.Else {
			elseBlock.Children = append(elseBlock.Children, FromStatement(stmt))
		}
		n.Children = append(n.Children, elseBlock)
	}

	return n
}

func fromForStmt(f *parser.ForStmt) *Node {
	return &Node{
		Kind:  "for",
		Value: f.Name,
		Children: []*Node{
			{Kind: "range", Children: []*Node{
				FromExpr(f.Start),
				FromExpr(f.End),
			}},
			{Kind: "block", Children: mapStatements(f.Body)},
		},
	}
}

func mapStatements(stmts []*parser.Statement) []*Node {
	var out []*Node
	for _, s := range stmts {
		out = append(out, FromStatement(s))
	}
	return out
}

func fromOnHandler(h *parser.OnHandler) *Node {
	n := &Node{Kind: "on", Value: h.Stream}
	for _, stmt := range h.Body {
		n.Children = append(n.Children, FromStatement(stmt))
	}
	return n
}

func fromIntent(i *parser.IntentDecl) *Node {
	n := &Node{Kind: "intent", Value: i.Name}
	for _, param := range i.Params {
		paramNode := &Node{Kind: "param", Value: param.Name}
		if param.Type != nil {
			paramNode.Children = append(paramNode.Children, FromTypeRef(param.Type))
		}
		n.Children = append(n.Children, paramNode)
	}
	if i.Return != nil {
		n.Children = append(n.Children, FromTypeRef(i.Return))
	}
	for _, stmt := range i.Body {
		n.Children = append(n.Children, FromStatement(stmt))
	}
	return n
}

func fromStreamField(f *parser.StreamField) *Node {
	if f.Simple != nil {
		return &Node{
			Kind:  "field",
			Value: f.Simple.Name + ":" + f.Simple.Type,
		}
	}
	if f.Nested != nil {
		n := &Node{
			Kind:  "field",
			Value: f.Nested.Name + ":" + f.Nested.Type,
		}
		for _, sf := range f.Nested.Body.Fields {
			n.Children = append(n.Children, fromStreamField(sf))
		}
		return n
	}
	return &Node{Kind: "field"}
}

// FromExpr converts a high-level expression.
func FromExpr(e *parser.Expr) *Node {
	return FromEquality(e.Equality)
}

func FromEquality(e *parser.Equality) *Node {
	n := FromComparison(e.Left)
	for _, op := range e.Right {
		n = &Node{Kind: "binary", Value: op.Op, Children: []*Node{n, FromComparison(op.Right)}}
	}
	return n
}

func FromComparison(c *parser.Comparison) *Node {
	n := FromTerm(c.Left)
	for _, op := range c.Right {
		n = &Node{Kind: "binary", Value: op.Op, Children: []*Node{n, FromTerm(op.Right)}}
	}
	return n
}

func FromTerm(t *parser.Term) *Node {
	n := FromFactor(t.Left)
	for _, op := range t.Right {
		n = &Node{Kind: "binary", Value: op.Op, Children: []*Node{n, FromFactor(op.Right)}}
	}
	return n
}

func FromFactor(f *parser.Factor) *Node {
	n := FromUnary(f.Left)
	for _, op := range f.Right {
		n = &Node{Kind: "binary", Value: op.Op, Children: []*Node{n, FromUnary(op.Right)}}
	}
	return n
}

func FromUnary(u *parser.Unary) *Node {
	n := FromPrimary(u.Value)
	for i := len(u.Ops) - 1; i >= 0; i-- {
		n = &Node{Kind: "unary", Value: u.Ops[i], Children: []*Node{n}}
	}
	return n
}

func FromPrimary(p *parser.Primary) *Node {
	switch {
	case p.FunExpr != nil:
		n := &Node{Kind: "funexpr"}
		for _, param := range p.FunExpr.Params {
			paramNode := &Node{Kind: "param", Value: param.Name}
			if param.Type != nil {
				paramNode.Children = append(paramNode.Children, FromTypeRef(param.Type))
			}
			n.Children = append(n.Children, paramNode)
		}
		if p.FunExpr.Return != nil {
			n.Children = append(n.Children, FromTypeRef(p.FunExpr.Return))
		}
		if p.FunExpr.ExprBody != nil {
			n.Children = append(n.Children, FromExpr(p.FunExpr.ExprBody))
		} else if len(p.FunExpr.BlockBody) > 0 {
			block := &Node{Kind: "block"}
			for _, stmt := range p.FunExpr.BlockBody {
				block.Children = append(block.Children, FromStatement(stmt))
			}
			n.Children = append(n.Children, block)
		}
		return n

	case p.Call != nil:
		n := &Node{Kind: "call", Value: p.Call.Func}
		for _, arg := range p.Call.Args {
			n.Children = append(n.Children, FromExpr(arg))
		}
		return n

	case p.Selector != nil:
		n := &Node{Kind: "selector", Value: p.Selector.Root}
		for _, field := range p.Selector.Tail {
			n = &Node{Kind: "selector", Value: field, Children: []*Node{n}}
		}
		return n

	case p.Lit != nil:
		switch {
		case p.Lit.Float != nil:
			return &Node{Kind: "float", Value: *p.Lit.Float}
		case p.Lit.Int != nil:
			return &Node{Kind: "int", Value: *p.Lit.Int}
		case p.Lit.Str != nil:
			return &Node{Kind: "string", Value: *p.Lit.Str}
		case p.Lit.Bool != nil:
			return &Node{Kind: "bool", Value: *p.Lit.Bool}
		}

	case p.Group != nil:
		return &Node{Kind: "group", Children: []*Node{FromExpr(p.Group)}}
	}
	return &Node{Kind: "unknown"}
}

// FromTypeRef converts a TypeRef (including function types) to a Node.
func FromTypeRef(t *parser.TypeRef) *Node {
	if t == nil {
		return nil
	}
	if t.Fun != nil {
		n := &Node{Kind: "typefun"}
		for _, param := range t.Fun.Params {
			n.Children = append(n.Children, FromTypeRef(param))
		}
		if t.Fun.Return != nil {
			n.Children = append(n.Children, FromTypeRef(t.Fun.Return))
		}
		return n
	}
	return &Node{Kind: "type", Value: *t.Simple}
}

```

## ast/pretty.go

```go
package ast

import (
	"fmt"

	"mochi/parser"
)

// PrettyStatement returns a readable description of a statement, including its source position.
func PrettyStatement(s *parser.Statement) string {
	switch {
	case s.Let != nil:
		return fmt.Sprintf("%s: let %s", s.Let.Pos, s.Let.Name)

	case s.Assign != nil:
		return fmt.Sprintf("%s: %s = ...", s.Assign.Pos, s.Assign.Name)

	case s.Fun != nil:
		return fmt.Sprintf("%s: fun %s(%d params)", s.Fun.Pos, s.Fun.Name, len(s.Fun.Params))

	case s.Expr != nil:
		return fmt.Sprintf("%s: expression", s.Expr.Pos)

	case s.Return != nil:
		return fmt.Sprintf("%s: return ...", s.Return.Pos)

	case s.If != nil:
		return fmt.Sprintf("%s: if ...", s.If.Pos)

	case s.For != nil:
		return fmt.Sprintf("%s: for %s in ...", s.For.Pos, s.For.Name)

	case s.On != nil:
		return fmt.Sprintf("%s: on %s as %s", s.On.Pos, s.On.Stream, s.On.Alias)

	case s.Agent != nil:
		return fmt.Sprintf("%s: agent %s", s.Agent.Pos, s.Agent.Name)

	case s.Stream != nil:
		return fmt.Sprintf("%s: stream %s", s.Stream.Pos, s.Stream.Name)

	case s.Test != nil:
		return fmt.Sprintf("%s: test %s", s.Test.Pos, s.Test.Name)

	case s.Expect != nil:
		return fmt.Sprintf("%s: expect %v", s.Expect.Pos, s.Expect.Value)

	default:
		return "unknown statement"
	}
}

```

## interpreter/env.go

```go
package interpreter

import (
	"fmt"
	"io"
	"mochi/parser"
	"os"
)

// Environment holds variable and function bindings with optional output writer.
type Environment struct {
	parent    *Environment
	vars      map[string]any
	functions map[string]*parser.FunStmt
	output    io.Writer
}

// NewEnv creates a new environment, possibly with a parent for lexical scope.
func NewEnv(parent *Environment) *Environment {
	return &Environment{
		parent:    parent,
		vars:      make(map[string]any),
		functions: make(map[string]*parser.FunStmt),
		output:    os.Stdout, // default output
	}
}

// Set defines a new variable in the current scope.
func (e *Environment) Set(name string, value any) {
	e.vars[name] = value
}

// Get looks up a variable in the current or parent environments.
func (e *Environment) Get(name string) (any, error) {
	if val, ok := e.vars[name]; ok {
		return val, nil
	}
	if e.parent != nil {
		return e.parent.Get(name)
	}
	return nil, fmt.Errorf("undefined variable: %s", name)
}

// Update modifies an existing variable. Fails if not declared.
func (e *Environment) Update(name string, value any) error {
	if _, ok := e.vars[name]; ok {
		e.vars[name] = value
		return nil
	}
	if e.parent != nil {
		return e.parent.Update(name, value)
	}
	return fmt.Errorf("variable not declared: %s", name)
}

// SetFunc defines a new function in the current scope.
func (e *Environment) SetFunc(name string, fn *parser.FunStmt) {
	e.functions[name] = fn
}

// GetFunc looks up a function in the current or parent environments.
func (e *Environment) GetFunc(name string) (*parser.FunStmt, bool) {
	if fn, ok := e.functions[name]; ok {
		return fn, true
	}
	if e.parent != nil {
		return e.parent.GetFunc(name)
	}
	return nil, false
}

// SetWriter overrides the output writer (defaults to os.Stdout).
func (e *Environment) SetWriter(w io.Writer) {
	e.output = w
}

// Writer returns the current output writer.
func (e *Environment) Writer() io.Writer {
	return e.output
}

```

## interpreter/interpreter.go

```go
package interpreter

import (
	"errors"
	"fmt"
	"mochi/ast"
	"mochi/parser"
)

// Interpreter executes Mochi programs.
type Interpreter struct {
	prog *parser.Program
	env  *Environment
}

func New(prog *parser.Program) *Interpreter {
	return &Interpreter{prog: prog, env: NewEnv(nil)}
}

func (i *Interpreter) Env() *Environment { return i.env }

func (i *Interpreter) Run() error {
	for _, stmt := range i.prog.Statements {
		if err := i.evalStmt(stmt); err != nil {
			return err
		}
	}
	return nil
}

// --- Statement Evaluation ---

func (i *Interpreter) evalStmt(s *parser.Statement) error {
	switch {
	case s.Let != nil:
		val := any(nil)
		var err error
		if s.Let.Value != nil {
			val, err = i.evalExpr(s.Let.Value)
			if err != nil {
				return err
			}
		}
		i.env.Set(s.Let.Name, val)
		return nil

	case s.Assign != nil:
		val, err := i.evalExpr(s.Assign.Value)
		if err != nil {
			return err
		}
		return i.env.Update(s.Assign.Name, val)

	case s.Expr != nil:
		_, err := i.evalExpr(s.Expr.Expr)
		return err

	case s.Fun != nil:
		i.env.SetFunc(s.Fun.Name, s.Fun)
		return nil

	case s.Return != nil:
		val, err := i.evalExpr(s.Return.Value)
		if err != nil {
			return err
		}
		return returnSignal{val}

	case s.If != nil:
		return i.evalIf(s.If)

	case s.For != nil:
		return i.evalFor(s.For)

	case s.Test != nil:
		fmt.Fprintf(i.env.Writer(), "üîç Test %s\n", s.Test.Name)
		child := NewEnv(i.env) // Isolated scope
		child.SetWriter(i.env.Writer())
		interp := &Interpreter{prog: i.prog, env: child}
		for _, stmt := range s.Test.Body {
			if err := interp.evalStmt(stmt); err != nil {
				return fmt.Errorf("‚ùå %s: %w", s.Test.Name, err)
			}
		}
		fmt.Fprintf(i.env.Writer(), "‚úÖ %s passed\n", s.Test.Name)
		return nil

	case s.Expect != nil:
		val, err := i.evalExpr(s.Expect.Value)
		if err != nil {
			return err
		}
		boolVal, ok := val.(bool)
		if !ok {
			return fmt.Errorf("expect requires a boolean, got %T", val)
		}
		if !boolVal {
			return fmt.Errorf("expect failed: %s", ast.PrettyStatement(s))
		}
		return nil

	case s.Agent != nil, s.Stream != nil:
		// No-op for now
		return nil

	default:
		return fmt.Errorf("unsupported statement: %s", ast.PrettyStatement(s))
	}
}

func (i *Interpreter) evalIf(stmt *parser.IfStmt) error {
	condVal, err := i.evalExpr(stmt.Cond)
	if err != nil {
		return err
	}
	if truthy(condVal) {
		for _, s := range stmt.Then {
			if err := i.evalStmt(s); err != nil {
				return err
			}
		}
		return nil
	}
	if stmt.ElseIf != nil {
		return i.evalIf(stmt.ElseIf)
	}
	for _, s := range stmt.Else {
		if err := i.evalStmt(s); err != nil {
			return err
		}
	}
	return nil
}

func (i *Interpreter) evalFor(stmt *parser.ForStmt) error {
	fromVal, err := i.evalExpr(stmt.Start)
	if err != nil {
		return err
	}
	toVal, err := i.evalExpr(stmt.End)
	if err != nil {
		return err
	}
	fromInt, ok1 := fromVal.(int)
	toInt, ok2 := toVal.(int)
	if !ok1 || !ok2 {
		return fmt.Errorf("range bounds must be integers, got %T and %T", fromVal, toVal)
	}

	for x := fromInt; x < toInt; x++ {
		i.env.Set(stmt.Name, x)
		for _, s := range stmt.Body {
			if err := i.evalStmt(s); err != nil {
				return err
			}
		}
	}
	return nil
}

// --- Expression Evaluation ---

func (i *Interpreter) evalExpr(e *parser.Expr) (any, error) {
	return i.evalEquality(e.Equality)
}

func (i *Interpreter) evalEquality(e *parser.Equality) (any, error) {
	left, err := i.evalComparison(e.Left)
	if err != nil {
		return nil, err
	}
	for _, op := range e.Right {
		right, err := i.evalComparison(op.Right)
		if err != nil {
			return nil, err
		}
		left, err = applyBinary(left, op.Op, right)
		if err != nil {
			return nil, err
		}
	}
	return left, nil
}

func (i *Interpreter) evalComparison(c *parser.Comparison) (any, error) {
	left, err := i.evalTerm(c.Left)
	if err != nil {
		return nil, err
	}
	for _, op := range c.Right {
		right, err := i.evalTerm(op.Right)
		if err != nil {
			return nil, err
		}
		left, err = applyBinary(left, op.Op, right)
		if err != nil {
			return nil, err
		}
	}
	return left, nil
}

func (i *Interpreter) evalTerm(t *parser.Term) (any, error) {
	left, err := i.evalFactor(t.Left)
	if err != nil {
		return nil, err
	}
	for _, op := range t.Right {
		right, err := i.evalFactor(op.Right)
		if err != nil {
			return nil, err
		}
		left, err = applyBinary(left, op.Op, right)
		if err != nil {
			return nil, err
		}
	}
	return left, nil
}

func (i *Interpreter) evalFactor(f *parser.Factor) (any, error) {
	left, err := i.evalUnary(f.Left)
	if err != nil {
		return nil, err
	}
	for _, op := range f.Right {
		right, err := i.evalUnary(op.Right)
		if err != nil {
			return nil, err
		}
		left, err = applyBinary(left, op.Op, right)
		if err != nil {
			return nil, err
		}
	}
	return left, nil
}

func (i *Interpreter) evalUnary(u *parser.Unary) (any, error) {
	val, err := i.evalPrimary(u.Value)
	if err != nil {
		return nil, err
	}
	for j := len(u.Ops) - 1; j >= 0; j-- {
		val, err = applyUnary(u.Ops[j], val)
		if err != nil {
			return nil, err
		}
	}
	return val, nil
}

func (i *Interpreter) evalPrimary(p *parser.Primary) (any, error) {
	switch {
	case p.FunExpr != nil:
		body := []*parser.Statement{}
		if p.FunExpr.ExprBody != nil {
			body = []*parser.Statement{
				{Return: &parser.ReturnStmt{Value: p.FunExpr.ExprBody}},
			}
		} else {
			body = p.FunExpr.BlockBody
		}
		closure := &Closure{
			Fun: &parser.FunStmt{
				Name:   "<closure>",
				Params: p.FunExpr.Params,
				Return: p.FunExpr.Return,
				Body:   body,
			},
			Env: i.env,
		}
		return closure, nil

	case p.Call != nil:
		return i.evalCall(p.Call)

	case p.Selector != nil:
		val, err := i.env.Get(p.Selector.Root)
		if err != nil {
			return nil, err
		}
		for _, field := range p.Selector.Tail {
			obj, ok := val.(map[string]any)
			if !ok {
				return nil, fmt.Errorf("cannot access field '%s' on non-object", field)
			}
			val = obj[field]
		}
		return val, nil

	case p.Lit != nil:
		return i.evalLiteral(p.Lit)

	case p.Group != nil:
		return i.evalExpr(p.Group)

	default:
		return nil, errors.New("invalid primary expression")
	}
}

func (i *Interpreter) evalLiteral(l *parser.Literal) (any, error) {
	switch {
	case l.Int != nil:
		var n int
		fmt.Sscanf(*l.Int, "%d", &n)
		return n, nil
	case l.Float != nil:
		var f float64
		fmt.Sscanf(*l.Float, "%f", &f)
		return f, nil
	case l.Str != nil:
		return *l.Str, nil
	case l.Bool != nil:
		return *l.Bool == "true", nil
	default:
		return nil, errors.New("invalid literal")
	}
}

// --- Function Calls ---

func (i *Interpreter) evalCall(c *parser.CallExpr) (any, error) {
	if c.Func == "print" {
		for _, arg := range c.Args {
			val, err := i.evalExpr(arg)
			if err != nil {
				return nil, err
			}
			fmt.Fprintf(i.env.Writer(), "%v ", val)
		}
		fmt.Fprintln(i.env.Writer())
		return nil, nil
	}

	var fn *parser.FunStmt
	var closureEnv *Environment
	var fnName string

	if f, ok := i.env.GetFunc(c.Func); ok {
		fn = f
		closureEnv = i.env
		fnName = f.Name
	} else {
		val, err := i.env.Get(c.Func)
		if err != nil {
			return nil, fmt.Errorf("undefined function or variable: %s", c.Func)
		}
		switch v := val.(type) {
		case *parser.FunStmt:
			fn = v
			closureEnv = i.env
			fnName = v.Name
		case *Closure:
			fn = v.Fun
			closureEnv = v.Env
			fnName = v.Fun.Name
		default:
			return nil, fmt.Errorf("value is not callable: %s (type %T)", c.Func, val)
		}
	}

	if len(c.Args) < len(fn.Params) {
		return nil, fmt.Errorf("arity mismatch: function %q expects %d args, but got %d", fnName, len(fn.Params), len(c.Args))
	}

	child := NewEnv(closureEnv)
	for idx, param := range fn.Params {
		val, err := i.evalExpr(c.Args[idx])
		if err != nil {
			return nil, fmt.Errorf("argument %d to function %q: %w", idx+1, fnName, err)
		}
		child.Set(param.Name, val)
	}

	old := i.env
	i.env = child
	defer func() { i.env = old }()

	for _, stmt := range fn.Body {
		if err := i.evalStmt(stmt); err != nil {
			if r, ok := err.(returnSignal); ok {
				result := r.value
				remainingArgs := c.Args[len(fn.Params):]

				for len(remainingArgs) > 0 {
					closure, ok := result.(*Closure)
					if !ok {
						return nil, fmt.Errorf("expected closure for partial application, got %T", result)
					}

					innerFn := closure.Fun
					if len(innerFn.Params) == 0 {
						return nil, fmt.Errorf("arity mismatch: function %q expects 0 args, but got 1", innerFn.Name)
					}

					arg := remainingArgs[0]
					argVal, err := i.evalExpr(arg)
					if err != nil {
						return nil, err
					}

					newEnv := NewEnv(closure.Env)
					newEnv.Set(innerFn.Params[0].Name, argVal)

					subInterp := &Interpreter{prog: i.prog, env: newEnv}
					result, err = subInterp.runFunctionBody(innerFn)
					if err != nil {
						return nil, err
					}
					remainingArgs = remainingArgs[1:]
				}
				return result, nil
			}
			return nil, err
		}
	}

	return nil, nil
}

func (i *Interpreter) runFunctionBody(fn *parser.FunStmt) (any, error) {
	for _, stmt := range fn.Body {
		if err := i.evalStmt(stmt); err != nil {
			if r, ok := err.(returnSignal); ok {
				return r.value, nil
			}
			return nil, err
		}
	}
	return nil, nil
}

// --- Return and Closures ---

type returnSignal struct{ value any }

func (r returnSignal) Error() string { return "return" }

type Closure struct {
	Fun *parser.FunStmt
	Env *Environment
}

// --- Operators ---

func applyBinary(left any, op string, right any) (any, error) {
	switch l := left.(type) {
	case int:
		if r, ok := right.(int); ok {
			return applyIntBinary(l, op, r)
		}
	case float64:
		if r, ok := right.(float64); ok {
			return applyFloatBinary(l, op, r)
		}
	case string:
		if r, ok := right.(string); ok {
			switch op {
			case "+":
				return l + r, nil
			case "==":
				return l == r, nil
			case "!=":
				return l != r, nil
			}
		}
	case bool:
		if r, ok := right.(bool); ok {
			switch op {
			case "==":
				return l == r, nil
			case "!=":
				return l != r, nil
			}
		}
	}
	return nil, fmt.Errorf("cannot apply operator '%s' to %T and %T", op, left, right)
}

func applyIntBinary(l int, op string, r int) (any, error) {
	switch op {
	case "+":
		return l + r, nil
	case "-":
		return l - r, nil
	case "*":
		return l * r, nil
	case "/":
		return l / r, nil
	case "==":
		return l == r, nil
	case "!=":
		return l != r, nil
	case "<":
		return l < r, nil
	case "<=":
		return l <= r, nil
	case ">":
		return l > r, nil
	case ">=":
		return l >= r, nil
	default:
		return nil, fmt.Errorf("unknown int operator: %s", op)
	}
}

func applyFloatBinary(l float64, op string, r float64) (any, error) {
	switch op {
	case "+":
		return l + r, nil
	case "-":
		return l - r, nil
	case "*":
		return l * r, nil
	case "/":
		return l / r, nil
	case "==":
		return l == r, nil
	case "!=":
		return l != r, nil
	case "<":
		return l < r, nil
	case "<=":
		return l <= r, nil
	case ">":
		return l > r, nil
	case ">=":
		return l >= r, nil
	default:
		return nil, fmt.Errorf("unknown float operator: %s", op)
	}
}

func applyUnary(op string, val any) (any, error) {
	switch op {
	case "-":
		switch v := val.(type) {
		case int:
			return -v, nil
		case float64:
			return -v, nil
		default:
			return nil, fmt.Errorf("unary '-' not supported on %T", val)
		}
	case "!":
		if b, ok := val.(bool); ok {
			return !b, nil
		}
		return nil, fmt.Errorf("unary '!' only supported on bool, got %T", val)
	default:
		return nil, fmt.Errorf("unknown unary operator: %s", op)
	}
}

func truthy(val any) bool {
	switch v := val.(type) {
	case bool:
		return v
	case int:
		return v != 0
	case float64:
		return v != 0.0
	case string:
		return v != ""
	default:
		return val != nil
	}
}

```

